---
title: "Clustering"
output: html_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Sampling clusters  


We decided to look further into sampling variables and make some transformation 

Let's look at all sampling related metrics and their histogram 


```{r}

sampling_temp <- main_dt[, c("sampling_total", "sampling_total_switch", "sampling_round_total",  "sampling_switch_ratio")]

ggplot(sampling_temp, aes(x = sampling_total)) + geom_histogram(binwidth = 2, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_total_switch " ,
       x = "Switching Total",
       y = "Frequency")

# --> right skewed

ggplot(sampling_temp, aes(x = sampling_total_switch)) + geom_histogram(binwidth = 2, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_total_switch " ,
       x = "sampling_total_switch",
       y = "Frequency")

# --> right skewed

ggplot(sampling_temp, aes(x = sampling_round_total)) + geom_histogram(binwidth = 2, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_round_total " ,
       x = "sampling_round_total",
       y = "Frequency")

# --> right skewed


ggplot(sampling_temp, aes(x = sampling_switch_ratio)) + geom_histogram(binwidth = 0.1, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_switch_ratio " ,
       x = "sampling_switch_ratio",
       y = "Frequency")
# --> bimodal 


```

We can use normalization (scale),  logartihmic transformation or Square root transformation for the right skewed ones 
Also use nromal distribution check after the transformation


```{r}

# Apply normalization
sampling_temp[, norm_sampling_total := scale(sampling_total)]
sampling_temp[, norm_sampling_total_switch := scale(sampling_total_switch)]

# histograms
ggplot(sampling_temp, aes(norm_sampling_total)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_total")
ggplot(sampling_temp, aes(norm_sampling_total_switch)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_total_switch")


# normal distribution tests
ks.test(sampling_temp$norm_sampling_total, "pnorm")
ks.test(sampling_temp$norm_sampling_total_switch, "pnorm")


# Apply logarithmic transformation
sampling_temp[, log_sampling_total := log(sampling_total)]
sampling_temp[, log_sampling_total_switch := log(sampling_total_switch)]

#histograms 
ggplot(sampling_temp, aes(log_sampling_total)) + geom_histogram(binwidth = 0.5) + labs(x = "log_sampling_total")
ggplot(sampling_temp, aes(log_sampling_total_switch)) + geom_histogram(binwidth = 0.5) + labs(x = "log_sampling_total_switch")


# normal distribution tests
ks.test(sampling_temp$log_sampling_total, "pnorm")
ks.test(sampling_temp$log_sampling_total_switch, "pnorm")

# Apply square root transformation
sampling_temp[, sr_sampling_total := sqrt(sampling_total)]
sampling_temp[, sr_sampling_total_switch := sqrt(sampling_total_switch)]

#histograms 
ggplot(sampling_temp, aes(sr_sampling_total)) + geom_histogram(binwidth = 1) + labs(x = "sr_sampling_total")
ggplot(sampling_temp, aes(sr_sampling_total_switch)) + geom_histogram(binwidth = 1) + labs(x = "sr_sampling_total_switch")

# normal distribution tests
ks.test(sampling_temp$sr_sampling_total, "pnorm")
ks.test(sampling_temp$sr_sampling_total_switch, "pnorm")

```


```{r}
# I will use similar simialr approaches for the ratios 
# but they are bimodel!

# I will try normalize, log, squared root transformation


# Apply normalization
sampling_temp[, norm_sampling_switch_ratio := scale(sampling_switch_ratio)]

# histograms
#ggplot(sampling_temp, aes(norm_sampling_ratio)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_ratio")
ggplot(sampling_temp, aes(norm_sampling_switch_ratio)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_switch_ratio")

# normal distribution tests
ks.test(sampling_temp$norm_sampling_switch_ratio, "pnorm")

# Apply logarithmic transformation
sampling_temp[, log_sampling_switch_ratio := log(sampling_switch_ratio)]

#histograms 
ggplot(sampling_temp, aes(log_sampling_switch_ratio)) + geom_histogram(binwidth = 0.5) + labs(x = "log_sampling_switch_ratio")



# normal distribution tests
ks.test(sampling_temp$log_sampling_switch_ratio, "pnorm")


# Apply square root transformation
sampling_temp[, sr_sampling_switch_ratio := sqrt(sampling_switch_ratio)]

#histograms 
#ggplot(sampling_temp, aes(sr_sampling_ratio)) + geom_histogram(binwidth = 0.1) + labs(x = "sr_sampling_ratio")
ggplot(sampling_temp, aes(sr_sampling_switch_ratio)) + geom_histogram(binwidth = 0.1) + labs(x = "sr_sampling_switch_ratio")


# normal distribution tests
ks.test(sampling_temp$sr_sampling_switch_ratio, "pnorm")


```

  - So I think the important metrics are switching ratio and sampling total for clustering
  - if we think low, medium and high for both of them, we should be expecting 9 clusters 
  - When we were calculating switching ratio, we decided to exclude first sampling but it caused 
  48 of NA data. Just to prevent it, I created sampling_switch_ratio_2 
  - I will create a sampling_real variable which is the sampling_total - sampling_total_switching to decrease the effect of sampling total 
  - I will check histogram of sampling ratio, sampling total, sampling_real
  - I will create a k-means cluster by using these 2 metrics with 9 clusters
  - If it doesn't pass the visual evaluation, I will try to create 9 clusters myself


```{r}

main_dt[, sampling_real := (sampling_total - sampling_total_switch)]

# create a graph sampling total vs sampling switch ratio 
ggplot(main_dt, aes(x = sampling_switch_ratio , y = sampling_total)) + geom_point()
ggplot(main_dt, aes(x = sampling_total_switch , y = sampling_real)) + geom_point()

```

```{r}
# Create histograms of sampling_total, sampling_real, sampling_switch_ratio
hist(main_dt$sampling_real)
hist(main_dt$sampling_total)
hist(main_dt$sampling_total_switch)
hist(main_dt$sampling_switch_ratio)

# let's use log transformation for the first two and scale for the last one. 


```



```{r}
# Sampling model 

model_dt<- as.data.table(main_dt[sampling_total_switch != 0, c("identifier","sampling_total", "sampling_total_switch", "sampling_real", "sampling_switch_ratio")])


# Apply logarithmic transformation
model_dt[, log_sampling_total_switch := log(sampling_total_switch)]
model_dt[, log_sampling_real := log(sampling_real)]


model_dt[, scale_sampling_total_switch := scale(sampling_total_switch)]
model_dt[, scale_sampling_real := scale(sampling_real)]

# Perform k-means clustering 
k <- 9
model_result <- kmeans(model_dt[, c("log_sampling_real", "log_sampling_total_switch")], centers = k, nstart = 10)

# Add the cluster assignments as a new column in the data table
model_dt$cluster <- as.factor(model_result$cluster)

# plots
ggplot(model_dt, aes(sampling_real, sampling_total_switch, color = cluster)) + geom_point()

ggplot(model_dt, aes(log_sampling_real, log_sampling_total_switch, color = cluster)) + geom_point()

ggplot(model_dt, aes(sampling_switch_ratio, sampling_total, color = cluster)) + geom_point()


```

```{r}
# scree plot 
# Initialize total within sum of squares error: wss
wss <- 0

# For 1 to 15 cluster centers
for (i in 1:15) {
  km.out <- kmeans(model_dt[, c("log_sampling_real", "log_sampling_total_switch")], centers = i)
  # Save total within sum of squares to wss variable
  wss[i] <- km.out$tot.withinss

}

# Plot total within sum of squares vs. number of clusters
plot(1:15, wss, type = "b", 
     xlab = "Number of Clusters", 
     ylab = "Within groups sum of squares")

```

## Sampling clusters vs. choice proportions

```{r}
# add cluster to main_dt and segment_dt
main_dt <- main_dt %>% left_join (model_dt, by = 'identifier')
segment_dt <- segment_dt %>% left_join(model_dt, by = 'identifier')

# Create graphs: sampling_switch_ratio vs seen_exval_chosen_proportion

ggplot(main_dt, aes(x = cluster, y = seen_exval_chosen_proportion)) + geom_line() + geom_point()

ggplot(segment_dt, aes(x = cluster, y = seen_exval_chosen_proportion)) + geom_line() + geom_point()


# Create graphs: sampling_switch_ratio vs seen_winner_chosen_proportion

ggplot(main_dt, aes(x = cluster , y = seen_winner_chosen_proportion)) + geom_line() + geom_point() + geom_smooth() + facet_grid(dom ~ . )

ggplot(segment_dt, aes(x = cluster, y = seen_winner_chosen_proportion)) + geom_line() + geom_point() + geom_smooth() + facet_grid(dom ~ . )


```




