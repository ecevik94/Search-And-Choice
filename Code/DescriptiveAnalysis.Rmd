---
title: "Descriptive data analysis"
author: "Emine"
date: "2023-06-18"
output: html_document
---

```{r setup, include = TRUE, echo = FALSE}
knitr::opts_chunk$set(message = FALSE)
```

```{r}
here::i_am("Code/DescriptiveAnalysis.Rmd")
```


```{r, warning = FALSE, echo = TRUE}
library(tidyverse)
library(openxlsx)
library(data.table)
library(ggplot2)
library(geomtextpath)
library(psych)
library(cluster)
library(here)
library(gridExtra)
library(MASS)
```

# Descriptive Analysis 
Here we are going to use "subset_dt.xlsx" (I created excel instead of csv because
it is easier to work on tableau). This file created based on DataCleaning_exp.rmd. 

Let's first read the table and briefly check if everything is okay.  
And do not forget that this is sampling paradigm, which means there is no feedback!!!!!!


```{r, warning = FALSE, echo = TRUE}
#read the file 
main_dt <- as.data.table(read.xlsx(here("Data", "subset_dt.xlsx")))
colnames(main_dt)
```
```{r, warning = FALSE, echo = TRUE}
# Start with simple descriptive 

# Number of different session (identifier) 
total_identifier <- main_dt[, .N]

# Total number of participants 
total_participant <- main_dt[, uniqueN(participant)]

# Total number of trials 
total_trial <- main_dt[, sum(sampling_total)]

# Average number of trials by identifier 
avg_trial_identifier <- main_dt[, mean(sampling_total)]


# Average identifier by participant 
# which shows the average number of problems that each 
# participant solve 
avg_questions <- total_identifier/total_participant

```


# Did participant see all outcomes within the trial?

```{r}

total_seen_all <- main_dt[seen_all == "TRUE", .N]
percentage_of_seen_all <- round(total_seen_all/total_identifier, 3)

print(paste0("Only in ", percentage_of_seen_all*100, "% of the run, participants saw all the outcomes"))


```

# Did the participant see similar distribution 
Here I decided to use heuristic 0,1 difference in probabilities 

```{r}
main_dt[, seen_similar_distA := ifelse(abs(seen_probA1 - probA1) <= 0.1, TRUE, FALSE)]
main_dt[, seen_similar_distB := ifelse(abs(seen_probB1 - probB1) <= 0.1, TRUE, FALSE)]
main_dt[, seen_similar_dist := ifelse(seen_similar_distA == TRUE & seen_similar_distB == TRUE, TRUE, FALSE)]

total_similar_dist <- main_dt[seen_similar_dist == TRUE, .N]
percentage_of_seen_similar_dist <- round(total_similar_dist / total_identifier, 3) 

print(paste0(percentage_of_seen_similar_dist*100, "% of the run, participants saw similar distribution to the description"))

```

# How much of the participant see similar distribution and all outcmes? 

```{r}
main_dt[, seen_similar := ifelse(seen_similar_dist == TRUE & seen_all == TRUE, TRUE, FALSE)]
total_seen_similar<- main_dt[seen_similar == TRUE, .N]
percentage_of_seen_similar <- round(total_seen_similar / total_identifier, 3) 

print(paste0(percentage_of_seen_similar*100, "% of the run, participants saw similar distribution with all outcomes to the description"))
```

# sampling total basics

``````{r, warning = FALSE, echo = TRUE}

mean(main_dt$sampling_total)
median(main_dt$sampling_total)
max(main_dt$sampling_total)
min(main_dt$sampling_total)

```
Histogram for trials (sampling total)

```{r, warning = FALSE, echo = TRUE}

# Create a histogram with a bin size of 2 
# added median line to the graph

ggplot(main_dt, aes(x = sampling_total)) + geom_histogram(binwidth = 2, fill="black", col="grey") + 
  geom_vline(xintercept = median(main_dt$sampling_total), linetype = "dashed", color = "red", size = 1) + 
  labs(title = "Histogram of Sampling Total",
       x = "Sampling Total",
       y = "Frequency")
```

# Switching basics

```{r,  warning = FALSE, echo = TRUE}

mean(main_dt$sampling_total_switch)
median(main_dt$sampling_total_switch)
max(main_dt$sampling_total_switch)
min(main_dt$sampling_total_switch)
```

Histogram for switchings (sampling total)

```{r, warning = FALSE, echo = TRUE}

# Create a histogram with a bin size of 2 
# added median line to the graph

ggplot(main_dt, aes(x = sampling_total_switch)) + geom_histogram(binwidth = 2, fill="black", col="grey") + 
  geom_vline(xintercept = median(main_dt$sampling_total_switch), linetype = "dashed", color = "red", size = 1) + 
  labs(title = "Histogram of Sampling Total",
       x = "Switching Total",
       y = "Frequency")
```

# Switching ratio 

# Create a histogram with a bin size of 
# added median line to the graph

```{r}
# Switch ratio definition 
# cleaned_exp[, sampling_switch_ratio := round(sampling_total_switch/(sampling_total-1), 3), by = identifier]

# Based on the definition, if the sampling total is equal to 1, the switch ratio will be NA 

# Create a histogram 
# added median line to the graph

# notice that I didn't include NA swtch ratio to median calculation

ggplot(main_dt, aes(x = sampling_switch_ratio)) + geom_histogram( fill="black", col="grey") + 
  geom_vline(xintercept = median(main_dt$sampling_switch_ratio, na.rm = TRUE), linetype = "dashed", color = "red", size = 1) + 
  labs(title = "Histogram of switching ratio",
       x = "Switching ratio",
       y = "Frequency")


```

# Relationship between sampling total (trials) and total switch 
``````{r, warning = FALSE, echo = TRUE}

ggplot(main_dt, aes(x = sampling_total, y = sampling_total_switch)) + geom_point() + 
  geom_textvline(label = "median of sampling total", xintercept = median(main_dt$sampling_total), color = "red") + 
  geom_texthline(label = "median of total switch", yintercept = median(main_dt$sampling_total_switch), color = "red") +
  geom_textabline(label = "median of switch ratio", slope = median(main_dt$sampling_switch_ratio, na.rm = TRUE), color = "red")
```
# Let's also check round ratio 

```{r}
# Round ratio definition 
# cleaned_exp[, sampling_switch_ratio := round(sampling_round_total/(sampling_total-1), 3), by = identifier]

main_dt[,sampling_round_ratio := round(sampling_round_total/(sampling_total-1),3)]

# Based on the definition, if the sampling total is equal to 1, the switch ratio will be NA 

# Create a histogram 
# added median line to the graph

# notice that I didn't include NA swtch ratio to median calculation

ggplot(main_dt, aes(x = sampling_round_ratio)) + geom_histogram( fill="black", col="grey") + 
  geom_vline(xintercept = median(main_dt$sampling_round_ratio, na.rm = TRUE), linetype = "dashed", color = "red", size = 1) + 
  labs(title = "Histogram of Round ratio",
       x = "Round ratio",
       y = "Frequency")


```


```{r}


ggplot(main_dt, aes(x = sampling_round_ratio)) + geom_histogram( fill="black", col="grey") + 
  geom_vline(xintercept = median(main_dt$sampling_round_ratio, na.rm = TRUE), linetype = "dashed", color = "red", size = 1) + 
  labs(title = "Histogram of Sampling Total",
       x = "Round ratio",
       y = "Frequency")

ggplot(main_dt, aes(x = sampling_total, y = sampling_round_total)) + geom_point() + 
  geom_textvline(label = "median of sampling total", xintercept = median(main_dt$sampling_total), color = "red") + 
  geom_texthline(label = "median of total round", yintercept = median(main_dt$sampling_round_total), color = "red") +
  geom_textabline(label = "median of round ratio", slope = median(main_dt$sampling_round_ratio, na.rm = TRUE), color = "red") +
  geom_textabline(label = "mean of round ratio", slope = mean(main_dt$sampling_round_ratio[is.finite(main_dt$sampling_round_ratio)]), color = "red")
```

# SAMPLING STRATEGIES 
## Let's try to find out the groups of sampling strategies based on sampling related columns 

```{r}

# the columns that I will work on : sampling_total, sampling_switch_ratio, "sampling_round_ratio

# Select the columns of interest
sampling_dt1.0 <- main_dt[is.finite(sampling_round_ratio), c("sampling_total", "sampling_switch_ratio", "sampling_round_ratio")]
sampling_dt1.1 <- main_dt[is.finite(sampling_round_ratio), c("sampling_total", "sampling_switch_ratio", "sampling_round_ratio", "sampling_total_switch", "sampling_round_total")]

#standardized data since k-means use euclidian distance 
scale_sampling_dt1.0 <- scale((sampling_dt1.0))

# Perform k-means clustering with 3 clusters
k <- 2
kmeans_result1 <- kmeans(scale_sampling_dt, centers = k)

# Add the cluster assignments as a new column in the data table
sampling_dt1.1$cluster <- as.factor(kmeans_result1$cluster)

# visualize the findings

ggplot(sampling_dt1.1, aes(x = sampling_total, y = sampling_total_switch, color = cluster)) + geom_point()

ggplot(sampling_dt1.1, aes(x = sampling_total, y = sampling_round_total, color = cluster)) + geom_point()


```
```{r}

# the columns that I will work on : sampling_total, sampling_total_switch",  "sampling_round_total

# Select the columns of interest
sampling_dt2.0 <- main_dt[is.finite(sampling_round_ratio), c("sampling_total", "sampling_total_switch", "sampling_round_total")]
sampling_dt2.1 <- main_dt[is.finite(sampling_round_ratio), c("sampling_total", "sampling_switch_ratio", "sampling_round_ratio", "sampling_total_switch", "sampling_round_total")]

#standardized data since k-means use euclidian distance 
scale_sampling_dt2.0 <- scale((sampling_dt2.0))

# Perform k-means clustering with 3 clusters
k <- 2
kmeans_result2 <- kmeans(scale_sampling_dt2.0, centers = k)

# Add the cluster assignments as a new column in the data table
sampling_dt2.1$cluster <- as.factor(kmeans_result2$cluster)

# visualize the findings

ggplot(sampling_dt2.1, aes(x = sampling_total, y = sampling_total_switch, color = cluster)) + geom_point()

ggplot(sampling_dt2.1, aes(x = sampling_total, y = sampling_round_total, color = cluster)) + geom_point()


```

```{r}

# the columns that I will work on : sampling_total, sampling_total_switch",  "sampling_round_total, sampling_round_ratio, sampling_switch_ratio

# Select the columns of interest
sampling_dt3.0 <- main_dt[is.finite(sampling_round_ratio), c("sampling_total", "sampling_switch_ratio", "sampling_round_ratio", "sampling_total_switch", "sampling_round_total")]
sampling_dt3.1 <- main_dt[is.finite(sampling_round_ratio), c("sampling_total", "sampling_switch_ratio", "sampling_round_ratio", "sampling_total_switch", "sampling_round_total")]

#standardized data since k-means use euclidian distance 
scale_sampling_dt3.0 <- scale((sampling_dt3.0))

# Perform k-means clustering with 3 clusters
k <- 2
kmeans_result3 <- kmeans(scale_sampling_dt3.0, centers = k)

# Add the cluster assignments as a new column in the data table
sampling_dt3.1$cluster <- as.factor(kmeans_result3$cluster)
main_dt[is.finite((sampling_round_ratio)), sampling_cluster := sampling_dt3.1$cluster]

# visualize the findings

ggplot(sampling_dt3.1, aes(x = sampling_total, y = sampling_total_switch, color = cluster)) + geom_point()

ggplot(sampling_dt3.1, aes(x = sampling_total, y = sampling_round_total, color = cluster)) + geom_point()


```

We decided to look further into sampling variables and make some transformation 

Let's look at all sampling related metrics and their histogram 

Try (sampling total - switching total) / sampling total here 

```{r}

main_dt[, sampling_ratio:= (sampling_total - sampling_total_switch)/(sampling_total)]

sampling_temp <- main_dt[is.finite(sampling_round_ratio), c("sampling_total", "sampling_total_switch", "sampling_round_total", "sampling_ratio",  "sampling_switch_ratio", "sampling_round_ratio")]

ggplot(sampling_temp, aes(x = sampling_total_switch)) + geom_histogram(binwidth = 2, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_total_switch " ,
       x = "Switching Total",
       y = "Frequency")

# --> right skewed

ggplot(sampling_temp, aes(x = sampling_total_switch)) + geom_histogram(binwidth = 2, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_total_switch " ,
       x = "sampling_total_switch",
       y = "Frequency")

# --> right skewed

ggplot(sampling_temp, aes(x = sampling_round_total)) + geom_histogram(binwidth = 2, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_round_total " ,
       x = "sampling_round_total",
       y = "Frequency")

# --> right skewed


ggplot(sampling_temp, aes(x = sampling_ratio)) + geom_histogram(binwidth = 0.1, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_ratio " ,
       x = "sampling_ratio",
       y = "Frequency")

# --> bimodal 


ggplot(sampling_temp, aes(x = sampling_switch_ratio)) + geom_histogram(binwidth = 0.1, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_switch_ratio " ,
       x = "sampling_switch_ratio",
       y = "Frequency")
# --> bimodal 

ggplot(sampling_temp, aes(x = sampling_round_ratio)) + geom_histogram(binwidth = 0.1, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_round_ratio " ,
       x = "sampling_round_ratio",
       y = "Frequency")
# --> bimodal ??

```

We can use normalization (scale),  logartihmic transformation or Square root transformation for the right skewed ones 
Also use nromal distribution check after the transformation


```{r}

# Apply normalization
sampling_temp[, norm_sampling_total := scale(sampling_total)]
sampling_temp[, norm_sampling_total_switch := scale(sampling_total_switch)]
sampling_temp[, norm_sampling_round_total := scale(sampling_round_total)]

# histograms
ggplot(sampling_temp, aes(norm_sampling_total)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_total")
ggplot(sampling_temp, aes(norm_sampling_total_switch)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_total_switch")
ggplot(sampling_temp, aes(norm_sampling_round_total)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_round_total")

# normal distribution tests
ks.test(sampling_temp$norm_sampling_total, "pnorm")
ks.test(sampling_temp$norm_sampling_total_switch, "pnorm")
ks.test(sampling_temp$norm_sampling_round_total, "pnorm")


# Apply logarithmic transformation
sampling_temp[, log_sampling_total := log(sampling_total)]
sampling_temp[, log_sampling_total_switch := log(sampling_total_switch)]
sampling_temp[, log_sampling_round_total := log(sampling_round_total)]

#histograms 
ggplot(sampling_temp, aes(log_sampling_total)) + geom_histogram(binwidth = 0.5) + labs(x = "log_sampling_total")
ggplot(sampling_temp, aes(log_sampling_total_switch)) + geom_histogram(binwidth = 0.5) + labs(x = "log_sampling_total_switch")
ggplot(sampling_temp, aes(log_sampling_round_total)) + geom_histogram(binwidth = 0.5) + labs(x = "log_sampling_round_total")


# normal distribution tests
ks.test(sampling_temp$log_sampling_total, "pnorm")
ks.test(sampling_temp$log_sampling_total_switch, "pnorm")
ks.test(sampling_temp$log_sampling_round_total, "pnorm")

# Apply square root transformation
sampling_temp[, sr_sampling_total := sqrt(sampling_total)]
sampling_temp[, sr_sampling_total_switch := sqrt(sampling_total_switch)]
sampling_temp[, sr_sampling_round_total := sqrt(sampling_round_total)]

#histograms 
ggplot(sampling_temp, aes(sr_sampling_total)) + geom_histogram(binwidth = 1) + labs(x = "sr_sampling_total")
ggplot(sampling_temp, aes(sr_sampling_total_switch)) + geom_histogram(binwidth = 1) + labs(x = "sr_sampling_total_switch")
ggplot(sampling_temp, aes(sr_sampling_round_total)) + geom_histogram(binwidth = 1) + labs(x = "sr_sampling_round_total")

# normal distribution tests
ks.test(sampling_temp$sr_sampling_total, "pnorm")
ks.test(sampling_temp$sr_sampling_total_switch, "pnorm")
ks.test(sampling_temp$sr_sampling_round_total, "pnorm")
```


```{r}
# I will use similar simialr approaches for the ratios 
# but they are bimodel!

# I will try normalize, log, squared root transformation


# Apply normalization
sampling_temp[, norm_sampling_ratio := scale(sampling_ratio)]
sampling_temp[, norm_sampling_switch_ratio := scale(sampling_switch_ratio)]
sampling_temp[, norm_sampling_round_ratio := scale(sampling_round_ratio)]

# histograms
#ggplot(sampling_temp, aes(norm_sampling_ratio)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_ratio")
ggplot(sampling_temp, aes(norm_sampling_switch_ratio)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_switch_ratio")
ggplot(sampling_temp, aes(norm_sampling_round_ratio)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_round_ratio")

# normal distribution tests
ks.test(sampling_temp$norm_sampling_ratio, "pnorm")
ks.test(sampling_temp$norm_sampling_switch_ratio, "pnorm")
ks.test(sampling_temp$norm_sampling_round_ratio, "pnorm")

# Apply logarithmic transformation
sampling_temp[, log_sampling_ratio := log(sampling_ratio)]
sampling_temp[, log_sampling_switch_ratio := log(sampling_switch_ratio)]
sampling_temp[, log_sampling_round_ratio := log(sampling_round_ratio)]

#histograms 
#ggplot(sampling_temp, aes(log_sampling_ratio)) + geom_histogram(binwidth = 0.5) + labs(x = "log_sampling_ratio")
ggplot(sampling_temp, aes(log_sampling_switch_ratio)) + geom_histogram(binwidth = 0.5) + labs(x = "log_sampling_switch_ratio")
ggplot(sampling_temp, aes(log_sampling_round_ratio)) + geom_histogram(binwidth = 0.5) + labs(x = "log_sampling_round_ratio")


# normal distribution tests
ks.test(sampling_temp$log_sampling_ratio, "pnorm")
ks.test(sampling_temp$log_sampling_switch_ratio, "pnorm")
ks.test(sampling_temp$log_sampling_round_ratio, "pnorm")


# Apply square root transformation
sampling_temp[, sr_sampling_ratio := sqrt(sampling_ratio)]
sampling_temp[, sr_sampling_switch_ratio := sqrt(sampling_switch_ratio)]
sampling_temp[, sr_sampling_round_ratio := sqrt(sampling_round_ratio)]

#histograms 
#ggplot(sampling_temp, aes(sr_sampling_ratio)) + geom_histogram(binwidth = 0.1) + labs(x = "sr_sampling_ratio")
ggplot(sampling_temp, aes(sr_sampling_switch_ratio)) + geom_histogram(binwidth = 0.1) + labs(x = "sr_sampling_switch_ratio")
ggplot(sampling_temp, aes(sr_sampling_round_ratio)) + geom_histogram(binwidth = 0.1) + labs(x = "sr_sampling_round_ratio")

# normal distribution tests
ks.test(sampling_temp$sr_sampling_ratio, "pnorm")
ks.test(sampling_temp$sr_sampling_switch_ratio, "pnorm")
ks.test(sampling_temp$sr_sampling_round_ratio, "pnorm")



```

```{r}
# Sampling model 

sampling_mod <- as.data.table(sampling_temp[is.finite(log_sampling_total_switch), c("sampling_total" , "sampling_round_total" , "sampling_total_switch", "sampling_ratio", "log_sampling_total", "log_sampling_total_switch", "log_sampling_round_total", "norm_sampling_ratio",  "norm_sampling_switch_ratio", "norm_sampling_round_ratio")])


# Perform k-means clustering 
k <- 2
kmeans_result <- kmeans(sampling_mod[, c("log_sampling_total", "log_sampling_total_switch", "log_sampling_round_total", "norm_sampling_ratio",  "norm_sampling_switch_ratio", "norm_sampling_round_ratio")], centers = k)

# Add the cluster assignments as a new column in the data table
sampling_mod$cluster <- as.factor(kmeans_result$cluster)
sampling_mod[ ,sampling_cluster := sampling_mod$cluster]

# visualize the findings

ggplot(sampling_mod, aes(x = sampling_total, y = sampling_total_switch, color = cluster)) + geom_point()

ggplot(sampling_dt3.1, aes(x = sampling_total, y = sampling_round_total, color = cluster)) + geom_point()

# boxplot for clusters and sampling_ratio 

ggplot(sampling_mod, aes(x = cluster, y = sampling_ratio)) + geom_boxplot() + xlab("Cluster") + ylab("Sampling Ratio")


# Perform t-test between clusters and sampling_ratio
t_test_result <- t.test(sampling_ratio ~ cluster, data = sampling_mod)

# Print the t-test results
print(t_test_result)

```

# Weekend Jul 1 and Jul 2 

  - I checked why I see different round/switch ratio. It was about when the participant stop and 
switch. I don't think it is an important behavior

  - So I think the important metrics are switching ratio and sampling total. 
  - if we think low, medium and hig for both of them, we should be expecting 9 clusters 
  - When we were calculating switching ratio, we decided to exclude first sampling but it caused 
  48 of NA data. Just to prevent it, I created sampling_switch_ratio_2 
  - I will create a sampling_real variable which is the sampling_total - sampling_total_switching to
  prevent multicollinearity problme in knn
  - I will check histogram of sampling ratio 2, sampling total, sampling_real
  - I will create a knn cluster by using these 2 metrics with 9 clusters
  - If it doesn't pass the visual evaluation, I will try to create 9 clusters myself


```{r}

# change the calculation of ratios 
main_dt[, sampling_switch_ratio_2 := sampling_total_switch/sampling_total]
main_dt[, sampling_real := (sampling_total - sampling_total_switch)]

# create a graph sampling total vs sampling switch ratio 
ggplot(main_dt, aes(x = sampling_switch_ratio_2 , y = sampling_total)) + geom_point()
ggplot(main_dt, aes(x = sampling_total_switch , y = sampling_real)) + geom_point()

```

```{r}
# Create histograms of sampling_total, sampling_real, sampling_switch_ratio
hist(main_dt$sampling_real)
hist(main_dt$sampling_total)
hist(main_dt$sampling_total_switch)
hist(main_dt$sampling_switch_ratio)

# let's use log transformation for the first two and scale for the last one. 


```



```{r}
# Sampling model 

model_dt<- as.data.table(main_dt[sampling_total_switch != 0, c("identifier","sampling_total", "sampling_total_switch", "sampling_real", "sampling_switch_ratio_2")])


# Apply logarithmic transformation
model_dt[, log_sampling_total_switch := log(sampling_total_switch)]
model_dt[, log_sampling_real := log(sampling_real)]


model_dt[, scale_sampling_total_switch := scale(sampling_total_switch)]
model_dt[, scale_sampling_real := scale(sampling_real)]

# Perform k-means clustering 
k <- 9
model_result <- kmeans(model_dt[, c("log_sampling_real", "log_sampling_total_switch")], centers = k, nstart = 10)

# Add the cluster assignments as a new column in the data table
model_dt$cluster <- as.factor(model_result$cluster)

# plots
ggplot(model_dt, aes(sampling_real, sampling_total_switch, color = cluster)) + geom_point()

ggplot(model_dt, aes(log_sampling_real, log_sampling_total_switch, color = cluster)) + geom_point()

ggplot(model_dt, aes(sampling_switch_ratio_2, sampling_total_switch, color = cluster)) + geom_point()

ggplot(model_dt, aes(sampling_switch_ratio_2, sampling_total, color = cluster)) + geom_point()

ggplot(model_dt, aes(sampling_switch_ratio_2, sampling_real, color = cluster)) + geom_point()


```

```{r}
# scree plot 
# Initialize total within sum of squares error: wss
wss <- 0

# For 1 to 15 cluster centers
for (i in 1:15) {
  km.out <- kmeans(model_dt[, c("log_sampling_real", "log_sampling_total_switch")], centers = i)
  # Save total within sum of squares to wss variable
  wss[i] <- km.out$tot.withinss

}

# Plot total within sum of squares vs. number of clusters
plot(1:15, wss, type = "b", 
     xlab = "Number of Clusters", 
     ylab = "Within groups sum of squares")

```


# DECISION STRATEGIES - JULY 2

```{r}

# Add cluster info to main_dt

main_dt <- merge(main_dt, model_dt[, c("identifier", "cluster")], by = "identifier", all.x = TRUE)

main_dt[, .N, by = c("cluster", "seen_all")][order(cluster)]
main_dt[, .N, by = c("cluster", "seen_exval_chosen")][order(cluster)]
main_dt[, .N, by = c("cluster", "seen_similar")][order(cluster)]

```









# DECISION STRATEGIES
Here we will use columns related to "seen" and try to identify decision strategies

  - Did they choose highest ev?
  - Did their choice strategy influenced by domain of the question?

```{r}
# let's add one more variable called seen_exval_chosen 
# it will return if the choice is aligned exval, false otherwise 

main_dt[, seen_exval_chosen := ifelse(is.null(seen_exval), NA, ifelse(choice == seen_exval, TRUE, FALSE)), by = identifier]

```

- Did they choose highest ev?
```{r}
table_dt1 <- main_dt[, .N, by = c("sampling_cluster", "seen_exval_chosen")][order(seen_exval_chosen)][order(sampling_cluster)]

table_dt1[, percent := N / sum(N) * 100, by = sampling_cluster]

table_dt1
```

- Did their choice strategy influenced by domain of the question?
```{r}

table_dt2 <- main_dt[, .N, by = c("dom", "sampling_cluster", "seen_exval_chosen")][order(seen_exval_chosen)][order(dom)][order(sampling_cluster)]

table_dt2[, percent := N / sum(N) * 100, by = c("sampling_cluster", "dom")]

table_dt2

```



# SAMPLING AND DECISION TOGETHER 
Here ww will try to identify the relationship between sampling and decision strategies 






