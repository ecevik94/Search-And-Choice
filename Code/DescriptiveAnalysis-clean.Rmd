---
title: "Descriptive data analysis - summary"
author: "Emine Cevik"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include = TRUE, echo = FALSE}
knitr::opts_chunk$set(message = FALSE)
```

```{r}
here::i_am("Code/DescriptiveAnalysis.Rmd")
```


```{r, warning = FALSE, echo = TRUE}
library(tidyverse)
library(openxlsx)
library(data.table)
library(ggplot2)
library(geomtextpath)
library(psych)
library(cluster)
library(here)
library(gridExtra)
library(MASS)
library(fpCompare)
library(caret)
library(ggridges)
```

# Descriptive Analysis 
  - I will use mostly subset_dt.csv
  - Switching ratio and proportion of choices (seen_exval_chosen & seen_winner_chosen) will be most important metrics
  
  - Sampling_total + switching ratio together will be used for sampling clusters which 
  will be secondary. --> Might be used for discussion later 
  
  - option has higher exval and option that is a winner for piecewise comparison 
    - check if they are the same option

## Create the data set and simple statistics related to the data source

```{r, warning = FALSE, echo = TRUE}
#read the file 
main_dt <- as.data.table(read.csv(here("Data", "subset_dt.csv")))
colnames(main_dt)
```

```{r, warning = FALSE, echo = TRUE}

# Number of different session (identifier) 
total_identifier <- main_dt[, .N]

# Total number of participants 
total_participant <- main_dt[, uniqueN(participant)]

# Total number of trials 
total_trial <- main_dt[, sum(sampling_total)]

# Average number of trials by identifier 
avg_trial_identifier <- main_dt[, mean(sampling_total)]


# Average identifier by participant 
# which shows the average number of problems that each 
# participant solve 
avg_questions <- total_identifier/total_participant

```


Did participant see all outcomes within the trial?

```{r}

total_seen_all <- main_dt[seen_all == "TRUE", .N]
percentage_of_seen_all <- round(total_seen_all/total_identifier, 3)

print(paste0("Only in ", percentage_of_seen_all*100, "% of the run, participants saw all the outcomes"))


```

Did the participant see similar distribution 

Similar distribution definition: as long as there is a difference between descriptive and seen probabilities less than 0,1, it is a similar distribution
** 0,1 is chosen by heuristic

```{r}
main_dt[, seen_similar_distA := ifelse(abs(seen_probA1 - probA1) <= 0.1, TRUE, FALSE)]
main_dt[, seen_similar_distB := ifelse(abs(seen_probB1 - probB1) <= 0.1, TRUE, FALSE)]
main_dt[, seen_similar_dist := ifelse(seen_similar_distA == TRUE & seen_similar_distB == TRUE, TRUE, FALSE)]

total_similar_dist <- main_dt[seen_similar_dist == TRUE, .N]
percentage_of_seen_similar_dist <- round(total_similar_dist / total_identifier, 3) 

print(paste0(percentage_of_seen_similar_dist*100, "% of the run, participants saw similar distribution to the description"))

```

How much of the participant see similar distribution and all outcomes? 

```{r}
main_dt[, seen_similar := ifelse(seen_similar_dist == TRUE & seen_all == TRUE, TRUE, FALSE)]
total_seen_similar<- main_dt[seen_similar == TRUE, .N]
percentage_of_seen_similar <- round(total_seen_similar / total_identifier, 3) 

print(paste0(percentage_of_seen_similar*100, "% of the run, participants saw similar distribution with all outcomes to the description"))
```

## Sampling-related metrics 

### Sampling_total: Total number of trial by identifier 

``````{r, warning = FALSE, echo = TRUE}

mean(main_dt$sampling_total)
median(main_dt$sampling_total)
max(main_dt$sampling_total)
min(main_dt$sampling_total)

main_dt[ sampling_total == 1, .N]

cat("mean: ", mean(main_dt$sampling_total), "\n")
cat("median: ", median(main_dt$sampling_total), "\n")
cat("max: ", max(main_dt$sampling_total), "\n")
cat("min: ", min(main_dt$sampling_total), "\n")

```
Histogram for sampling total 

```{r, warning = FALSE, echo = TRUE}

# Create a histogram with a bin size of  
# added median line to the graph

ggplot(main_dt, aes(x = sampling_total)) + geom_histogram(binwidth = 1, fill="black", col="grey") + 
  geom_vline(xintercept = median(main_dt$sampling_total), linetype = "dashed", color = "red", size = 1) + 
  labs(title = "Histogram of Sampling Total",
       x = "Sampling Total",
       y = "Frequency") + theme_ridges()
```

- We seem right skewed histogram, with the local peaks for 2, 4, 10, 20. 

- 2 is the most frequent sampling_total

- Numbers are aligned with Meta-Analytic Review of Two Modes paper

```{r}

ggplot(main_dt, aes(x = sampling_total)) + geom_density(aes(color = dom)) + theme_ridges()

```
Different domains also have similar distribution.

```{r}

ggplot(main_dt, aes(x = dom, y = sampling_total)) + geom_violin() + theme_ridges()

```

### sampling_total_switch: number of times the participant chance option sampled

```{r,  warning = FALSE, echo = TRUE}

mean(main_dt$sampling_total_switch)
median(main_dt$sampling_total_switch)
max(main_dt$sampling_total_switch)
min(main_dt$sampling_total_switch)

cat("mean: ", mean(main_dt$sampling_total_switch), "\n")
cat("median: ", median(main_dt$sampling_total_switch), "\n")
cat("max: ", max(main_dt$sampling_total_switch), "\n")
cat("min: ", min(main_dt$sampling_total_switch), "\n")

main_dt[ sampling_total_switch == 0, .N]
```

Histogram of switching total

```{r, warning = FALSE, echo = TRUE}

# Create a histogram with a bin size of 2 
# added median line to the graph

ggplot(main_dt, aes(x = sampling_total_switch)) + geom_histogram(binwidth = 1, fill="black", col="grey") + 
  geom_vline(xintercept = median(main_dt$sampling_total_switch), linetype = "dashed", color = "red", size = 1) + 
  labs(title = "Histogram of Sampling Total",
       x = "Switching Total",
       y = "Frequency") +  theme_ridges()
```
Similar to sampling_total, we see right skewed histogram for sampling_total_switch
 

```{r}

ggplot(main_dt, aes(x = sampling_total_switch)) + geom_density(aes(color = dom)) + theme_ridges()

```

The distribution of sampling_total_switch is quite similar for the different domains. 

```{r}

ggplot(main_dt, aes(x = dom, y = sampling_total_switch)) + geom_violin() + theme_ridges()

```
### Switching ratio : (sampling_total_switch/ (sampling_total - 1 ))


```{r}
mean(main_dt$sampling_switch_ratio, na.rm = TRUE)
median(main_dt$sampling_switch_ratio, na.rm = TRUE)
max(main_dt$sampling_switch_ratio, na.rm = TRUE)
min(main_dt$sampling_switch_ratio, na.rm = TRUE)

main_dt[is.na(sampling_switch_ratio) , .N]

```

Histogram of switching ratio

```{r}
# cleaned_exp[, sampling_switch_ratio := round(sampling_total_switch/(sampling_total-1), 3), by = identifier]

# Based on the definition, if the sampling total is equal to 1, the switch ratio will be NA 

# Create a histogram 
# added median line to the graph

# notice that I didn't include NA swtch ratio to median calculation

ggplot(main_dt, aes(x = sampling_switch_ratio)) + geom_histogram( fill="black", col="grey") + 
  geom_vline(xintercept = median(main_dt$sampling_switch_ratio, na.rm = TRUE), linetype = "dashed", color = "red", size = 1) + 
  labs(title = "Histogram of switching ratio",
       x = "Switching ratio",
       y = "Frequency") + theme_ridges()


```

It is interesting to see high number of cases where switching ratio is equal to 1. 

(When it is closer to 1, it shows frequent switching behavior)

Also it seems like there are clearly two different groups which is what we can pursue and ask questions about them 

--> Bimodel distribution


```{r}

ggplot(main_dt, aes(x = sampling_switch_ratio)) + geom_density(aes(color = dom)) + theme_ridges()

```

```{r}

ggplot(main_dt, aes(x = dom, y = sampling_switch_ratio)) + geom_violin() + theme_ridges() +
  scale_y_continuous(limits=c(-0.5 , 1.5))

```
When domain is mixed, we see higher proportion of low switching ratio compared to others. 

Is there any significant difference between 3 groups ?

```{r}
# ANOVA
# Compute the analysis of variance
res.aov <- aov(sampling_switch_ratio ~ dom, data = main_dt)
# Summary of the analysis
summary(res.aov)

```
significant difference

*BUT AND BIG BUT*

Anova's assumptions of normality & equal variances are not met

### Relationship between sampling_total and sampling_switch_ratio

```{r}
# create sampling_switch_ratio_2, by round sampling_switch_ratio to 2 
main_dt[, sampling_switch_ratio_2 := round(sampling_total_switch/(sampling_total - 1), 2)]

# create sampling_switch_ratio_1, by round sampling_switch_ratio to 1
main_dt[, sampling_switch_ratio_1 := round(sampling_total_switch/(sampling_total - 1), 1)]
```


sampling_total vs sampling_switch_ratio_mean

```{r}

# find the mean sampling_switch_ratio by sampling_total 
main_dt[, sampling_switch_ratio_mean := round(mean(sampling_switch_ratio),2), by = sampling_total]

#ggplot(main_dt, aes( x = sampling_total, y = sampling_switch_ratio_mean)) + geom_point() 
ggplot(main_dt) + geom_point( aes( x = sampling_total, y = sampling_switch_ratio), color = "gray", fill = "gray") +
  geom_point(aes( x = sampling_total, y = sampling_switch_ratio_mean) ,color = "red", fill = "red") 

ggplot(main_dt) + geom_point( aes( x = sampling_total, y = sampling_switch_ratio), color = "gray", fill = "gray") +
  geom_point(aes( x = sampling_total, y = sampling_switch_ratio_mean) ,color = "red", fill = "red") + facet_grid(dom ~ .)

#cor(main_dt$sampling_total, main_dt$sampling_switch_ratio_mean)
```
High switching ratio --> low number samples 

Correlation between switch ratio and sampling total

```{r}

cor(main_dt$sampling_total, main_dt$sampling_switch_ratio_mean, use = "complete.obs")

```

# Sampling strategies 

The most important question will ask will be : How is sampling switch ratio and proportion of seen_exval and seen_winner work together?

Before going into details for that, let's check seen_exval and seen_exval_chosen and understand their definition clearly. 

seen_exval shows the which option has higher expected value. If both option have same expected value, then it will be NA. Same definition used with "exval" 

!!!! Question: When is the difference between seen_evA and seen_evB significantly small? --> Ignore

## Create seen_winner_chosen and seen_exval_chosen

```{r}

#Seen_exval_chosen and seen_winner_chosen 
# - when seen_A or seen_B is not 0 which means, participant sampled from each outcome, 
# I check if the choice and seen_exval or seen_seen_winner are same. If seen_exval or seen_seen_winner is NA
# I also return TRUE 

main_dt[, seen_exval_chosen_NA := ifelse(seen_A == 0 | seen_B == 0, "unidentified", 
                                      ifelse((choice == seen_exval) | is.na(seen_exval), TRUE, FALSE))]

main_dt[, seen_winner_chosen_NA := ifelse(seen_A == 0 | seen_B == 0, "unidentified", 
                                      ifelse((choice == seen_winner) | is.na(seen_winner), TRUE, FALSE))]

# Since I didn't like this for seen_winner_chosen_NA, I will also create seen_winner_chosen
# in this case if seen_winner is NA, it will be also unidentified. Similarly for seen_exval

main_dt[, seen_exval_chosen := ifelse(seen_A == 0 | seen_B == 0, "unidentified", 
                                      ifelse(is.na(seen_exval), "special_chosen", ifelse(choice == seen_exval , TRUE, FALSE)))]

main_dt[, seen_winner_chosen := ifelse(seen_A == 0 | seen_B == 0, "unidentified", 
                                      ifelse(is.na(seen_winner), "special_winner", ifelse(choice == seen_winner , TRUE, FALSE)))]

```


## Decision variables descriptives

```{r}

# seen_exval_chosen and seen_winner_chosen are used to calculate choice proportions later on. Before comparing the relations between 
# switching ratio and decision metrics, we can briefly check some descriptives 

main_dt[, .N , by = seen_exval_chosen]

main_dt[, .N , by = seen_winner_chosen]

main_dt[, .N , by = seen_exval_chosen_NA]

main_dt[, .N , by = seen_winner_chosen_NA]

table(main_dt$seen_exval_chosen, main_dt$seen_winner_chosen)

table(main_dt$seen_exval_chosen_NA, main_dt$seen_winner_chosen_NA)

```


### Switching probabilities vs. decision variables 

Preparation 

1- Data already has 3 types of sampling_switch_ratio
  - sampling_switch_ratio: 3 decimal 
  - sampling_switch_ratio_2: 2 decimal 
  - sampling_switch_ratio_1: 1 decimal 
  
2- Create a column called seen_exval_winner_same 
  - It will show if seen_exval and seen_winner are same 
  - if seen_exval is NA and seen_A and seen_B are not equal to 0 (where seen_evA and seen_evB are equal) return true too
  
3- Create seen_exval_chosen_proportion based on  
  - sampling_switch_ratio: 3 decimal 
  - sampling_switch_ratio_2: 2 decimal 
  - sampling_switch_ratio_1: 1 decimal 
  
4- Create seen_winner_chosen_proportion based on 
  - sampling_switch_ratio: 3 decimal 
  - sampling_switch_ratio_2: 2 decimal 
  - sampling_switch_ratio_1: 1 decimal 

```{r}

# Step 1 is already done 

# Step 2: column seen_exval_winner_same 

main_dt[, seen_exval_winner_same := ifelse(seen_A == 0 | seen_B == 0, "unidentified", 
                                           ifelse(is.na(seen_exval) | is.na(seen_winner), "special", 
                                                  ifelse(seen_exval == seen_winner, TRUE, FALSE)))]

main_dt[, seen_exval_winner_same_NA := ifelse(seen_A == 0 | seen_B == 0, "unidentified", 
                                              ifelse(seen_exval == seen_winner | is.na(seen_exval) | is.na(seen_winner), TRUE, FALSE))]


# Calculate proportion of seen_exval_chosen
main_dt[, seen_exval_chosen_proportion := round(sum(seen_exval_chosen == TRUE, na.rm = TRUE) / .N ,3), by = sampling_switch_ratio]
main_dt[, seen_exval_chosen_proportion_1 := round(sum(seen_exval_chosen == TRUE, na.rm = TRUE) / .N ,3), by = sampling_switch_ratio_1]
main_dt[, seen_exval_chosen_proportion_2 := round(sum(seen_exval_chosen == TRUE, na.rm = TRUE) / .N ,3), by = sampling_switch_ratio_2]


# Calculate proportion of seen_winner_chosen
main_dt[, seen_winner_chosen_proportion := round(sum(seen_winner_chosen == TRUE, na.rm = TRUE) / .N ,3), by = sampling_switch_ratio]
main_dt[, seen_winner_chosen_proportion_1 := round(sum(seen_winner_chosen == TRUE, na.rm = TRUE) / .N ,3), by = sampling_switch_ratio_1]
main_dt[, seen_winner_chosen_proportion_2 := round(sum(seen_winner_chosen == TRUE, na.rm = TRUE) / .N ,3), by = sampling_switch_ratio_2]

# Calculate proportion of seen_exval_chosen_NA
main_dt[, seen_exval_chosen_proportion_NA := round(sum(seen_exval_chosen_NA == TRUE, na.rm = TRUE) / .N ,3), by = sampling_switch_ratio]
main_dt[, seen_exval_chosen_proportion_1_NA := round(sum(seen_exval_chosen_NA == TRUE, na.rm = TRUE) / .N ,3), by = sampling_switch_ratio_1]
main_dt[, seen_exval_chosen_proportion_2_NA  := round(sum(seen_exval_chosen_NA == TRUE, na.rm = TRUE) / .N ,3), by = sampling_switch_ratio_2]


# Calculate proportion of seen_winner_chosen_NA
main_dt[, seen_winner_chosen_proportion_NA := round(sum(seen_winner_chosen_NA == TRUE, na.rm = TRUE) / .N ,3), by = sampling_switch_ratio]
main_dt[, seen_winner_chosen_proportion_1_NA := round(sum(seen_winner_chosen_NA == TRUE, na.rm = TRUE) / .N ,3), by = sampling_switch_ratio_1]
main_dt[, seen_winner_chosen_proportion_2_NA := round(sum(seen_winner_chosen_NA == TRUE, na.rm = TRUE) / .N ,3), by = sampling_switch_ratio_2]

              
```

GRAPHS with all data 
  - proportions that include NA will have higher average 
```{r}

# Create graphs: sampling_switch_ratio vs seen_exval_chosen_proportion & seen_winner_chosen_proportion

ggplot(main_dt ,aes(x = sampling_switch_ratio_2, y = seen_exval_chosen_proportion_2)) + geom_point() + facet_grid(dom ~ .) 

ggplot(main_dt, aes(x = sampling_switch_ratio_2, y = seen_exval_chosen_proportion_2_NA)) + geom_point() + facet_grid(dom ~ .) 

ggplot(main_dt, aes(x = sampling_switch_ratio_2, y = seen_winner_chosen_proportion_2)) + geom_point() + facet_grid(dom ~ .) 

ggplot(main_dt, aes(x = sampling_switch_ratio_2, y = seen_winner_chosen_proportion_2_NA)) + geom_point() + facet_grid(dom ~ .) 


```
```{r}

adhoc <- main_dt[seen_exval_winner_same == FALSE, ]

adhoc[, seen_winner_chosen_proportion_wip := round(sum(seen_winner_chosen == TRUE, na.rm = TRUE) / .N ,3), by = dom]
adhoc[, seen_exval_chosen_proportion_wip := round(sum(seen_exval_chosen == TRUE, na.rm = TRUE) / .N ,3), by = dom]
adhoc[, .(mean(seen_winner_chosen_proportion_wip), mean(seen_exval_chosen_proportion_wip) ), by = dom]

```

We see more significant different in domain than switch_ratio when it comes to domain. 

# Data is for modelling
```{r}

write.csv(main_dt, file = here("Data", "main_dt_model.csv"), row.names = FALSE)

```



