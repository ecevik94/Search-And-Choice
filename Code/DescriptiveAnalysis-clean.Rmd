---
title: "Descriptive data analysis - summary"
author: "Emine Cevik"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include = TRUE, echo = FALSE}
knitr::opts_chunk$set(message = FALSE)
```

```{r}
here::i_am("Code/DescriptiveAnalysis.Rmd")
```


```{r, warning = FALSE, echo = TRUE}
library(tidyverse)
library(openxlsx)
library(data.table)
library(ggplot2)
library(geomtextpath)
library(psych)
library(cluster)
library(here)
library(gridExtra)
library(MASS)
library(fpCompare)
library(caret)
library(ggridges)
```

# Descriptive Analysis 
  - I will use mostly subset_dt.csv
  - Switching ratio and proportion of choices (seen_exval_chosen & seen_winner_chosen) will be most important metrics
  
  - Sampling_total + switching ratio together will be used for sampling clusters which 
  will be secondary. --> Might be used for discussion later 
  
  - option has higher exval and option that is a winner for piecewise comparison 
    - check if they are the same option

## Create the data set and simple statistics related to the data source

```{r, warning = FALSE, echo = TRUE}
#read the file 
main_dt <- as.data.table(read.csv(here("Data", "subset_dt.csv")))
colnames(main_dt)
```

```{r, warning = FALSE, echo = TRUE}

# Number of different session (identifier) 
total_identifier <- main_dt[, .N]

# Total number of participants 
total_participant <- main_dt[, uniqueN(participant)]

# Total number of trials 
total_trial <- main_dt[, sum(sampling_total)]

# Average number of trials by identifier 
avg_trial_identifier <- main_dt[, mean(sampling_total)]


# Average identifier by participant 
# which shows the average number of problems that each 
# participant solve 
avg_questions <- total_identifier/total_participant

```


Did participant see all outcomes within the trial?

```{r}

total_seen_all <- main_dt[seen_all == "TRUE", .N]
percentage_of_seen_all <- round(total_seen_all/total_identifier, 3)

print(paste0("Only in ", percentage_of_seen_all*100, "% of the run, participants saw all the outcomes"))


```

Did the participant see similar distribution 

Similar distribution definition: as long as there is a difference between descriptive and seen probabilities less than 0,1, it is a similar distribution
** 0,1 is chosen by heuristic

```{r}
main_dt[, seen_similar_distA := ifelse(abs(seen_probA1 - probA1) <= 0.1, TRUE, FALSE)]
main_dt[, seen_similar_distB := ifelse(abs(seen_probB1 - probB1) <= 0.1, TRUE, FALSE)]
main_dt[, seen_similar_dist := ifelse(seen_similar_distA == TRUE & seen_similar_distB == TRUE, TRUE, FALSE)]

total_similar_dist <- main_dt[seen_similar_dist == TRUE, .N]
percentage_of_seen_similar_dist <- round(total_similar_dist / total_identifier, 3) 

print(paste0(percentage_of_seen_similar_dist*100, "% of the run, participants saw similar distribution to the description"))

```

How much of the participant see similar distribution and all outcomes? 

```{r}
main_dt[, seen_similar := ifelse(seen_similar_dist == TRUE & seen_all == TRUE, TRUE, FALSE)]
total_seen_similar<- main_dt[seen_similar == TRUE, .N]
percentage_of_seen_similar <- round(total_seen_similar / total_identifier, 3) 

print(paste0(percentage_of_seen_similar*100, "% of the run, participants saw similar distribution with all outcomes to the description"))
```

## Sampling-related metrics 

### Sampling_total: Total number of trial by identifier 

``````{r, warning = FALSE, echo = TRUE}

mean(main_dt$sampling_total)
median(main_dt$sampling_total)
max(main_dt$sampling_total)
min(main_dt$sampling_total)

main_dt[ sampling_total == 1, .N]

cat("mean: ", mean(main_dt$sampling_total), "\n")
cat("median: ", median(main_dt$sampling_total), "\n")
cat("max: ", max(main_dt$sampling_total), "\n")
cat("min: ", min(main_dt$sampling_total), "\n")

```
Histogram for sampling total 

```{r, warning = FALSE, echo = TRUE}

# Create a histogram with a bin size of  
# added median line to the graph

ggplot(main_dt, aes(x = sampling_total)) + geom_histogram(binwidth = 1, fill="black", col="grey") + 
  geom_vline(xintercept = median(main_dt$sampling_total), linetype = "dashed", color = "red", size = 1) + 
  labs(title = "Histogram of Sampling Total",
       x = "Sampling Total",
       y = "Frequency") + theme_ridges()
```

- We seem right skewed histogram, with the local peaks for 2, 4, 10, 20. 

- 2 is the most frequent sampling_total

- Numbers are aligned with Meta-Analytic Review of Two Modes paper

```{r}

ggplot(main_dt, aes(x = sampling_total)) + geom_density(aes(color = dom)) + theme_ridges()

```
Different domains also have similar distribution.

```{r}

ggplot(main_dt, aes(x = dom, y = sampling_total)) + geom_violin() + theme_ridges()

```

### sampling_total_switch: number of times the participant chance option sampled

```{r,  warning = FALSE, echo = TRUE}

mean(main_dt$sampling_total_switch)
median(main_dt$sampling_total_switch)
max(main_dt$sampling_total_switch)
min(main_dt$sampling_total_switch)

cat("mean: ", mean(main_dt$sampling_total_switch), "\n")
cat("median: ", median(main_dt$sampling_total_switch), "\n")
cat("max: ", max(main_dt$sampling_total_switch), "\n")
cat("min: ", min(main_dt$sampling_total_switch), "\n")

main_dt[ sampling_total_switch == 0, .N]
```

Histogram of switching total

```{r, warning = FALSE, echo = TRUE}

# Create a histogram with a bin size of 2 
# added median line to the graph

ggplot(main_dt, aes(x = sampling_total_switch)) + geom_histogram(binwidth = 1, fill="black", col="grey") + 
  geom_vline(xintercept = median(main_dt$sampling_total_switch), linetype = "dashed", color = "red", size = 1) + 
  labs(title = "Histogram of Sampling Total",
       x = "Switching Total",
       y = "Frequency") +  theme_pubr()
```
Similar to sampling_total, we see right skewed histogram for sampling_total_switch
 

```{r}

ggplot(main_dt, aes(x = sampling_total_switch)) + geom_density(aes(color = dom)) + theme_ridges()

```

The distribution of sampling_total_switch is quite similar for the different domains. 

```{r}

ggplot(main_dt, aes(x = dom, y = sampling_total_switch)) + geom_violin() + theme_ridges()

```
### Switching ratio : (sampling_total_switch/ (sampling_total - 1 ))


```{r}
mean(main_dt$sampling_switch_ratio, na.rm = TRUE)
median(main_dt$sampling_switch_ratio, na.rm = TRUE)
max(main_dt$sampling_switch_ratio, na.rm = TRUE)
min(main_dt$sampling_switch_ratio, na.rm = TRUE)

main_dt[is.na(sampling_switch_ratio) , .N]

```

Histogram of switching ratio

```{r}
# cleaned_exp[, sampling_switch_ratio := round(sampling_total_switch/(sampling_total-1), 3), by = identifier]

# Based on the definition, if the sampling total is equal to 1, the switch ratio will be NA 

# Create a histogram 
# added median line to the graph

# notice that I didn't include NA swtch ratio to median calculation

ggplot(main_dt, aes(x = sampling_switch_ratio)) + geom_histogram( fill="black", col="grey") + 
  geom_vline(xintercept = median(main_dt$sampling_switch_ratio, na.rm = TRUE), linetype = "dashed", color = "red", size = 1) + 
  labs(title = "Histogram of switching ratio",
       x = "Switching ratio",
       y = "Frequency") + theme_ridges()


```

It is interesting to see high number of cases where switching ratio is equal to 1. 

(When it is closer to 1, it shows frequent switching behavior)

Also it seems like there are clearly two different groups which is what we can pursue and ask questions about them 

--> Bimodel distribution


```{r}

ggplot(main_dt, aes(x = sampling_switch_ratio)) + geom_density(aes(color = dom)) + theme_ridges()

```

```{r}

ggplot(main_dt, aes(x = dom, y = sampling_switch_ratio)) + geom_violin() + theme_ridges() +
  scale_y_continuous(limits=c(-0.5 , 1.5))

```
When domain is meixed, we see higher proportion of low switching ratio compared to others. 

Is there any significant difference between 3 groups ?

```{r}

# Compute the analysis of variance
res.aov <- aov(sampling_switch_ratio ~ dom, data = main_dt)
# Summary of the analysis
summary(res.aov)

```
significant difference

*BUT AND BIG BUT*

Anova's assumptions of normality & equal variances are not met

### Relationship between sampling_total and sampling_switch_ratio

```{r}
# create sampling_switch_ratio_2, by round sampling_switch_ratio to 2 
main_dt[, sampling_switch_ratio_2 := round(sampling_total_switch/(sampling_total - 1), 2)]

# create sampling_switch_ratio_1, by round sampling_switch_ratio to 1
main_dt[, sampling_switch_ratio_1 := round(sampling_total_switch/(sampling_total - 1), 1)]
```


sampling_total vs sampling_switch_ratio_mean

```{r}

# find the mean sampling_switch_ratio by sampling_total 
main_dt[, sampling_switch_ratio_mean := round(mean(sampling_switch_ratio),2), by = sampling_total]

#ggplot(main_dt, aes( x = sampling_total, y = sampling_switch_ratio_mean)) + geom_point() 
ggplot(main_dt) + geom_point( aes( x = sampling_total, y = sampling_switch_ratio), color = "gray", fill = "gray") +
  geom_point(aes( x = sampling_total, y = sampling_switch_ratio_mean) ,color = "red", fill = "red") 

ggplot(main_dt) + geom_point( aes( x = sampling_total, y = sampling_switch_ratio), color = "gray", fill = "gray") +
  geom_point(aes( x = sampling_total, y = sampling_switch_ratio_mean) ,color = "red", fill = "red") + facet_grid(dom ~ .)

#cor(main_dt$sampling_total, main_dt$sampling_switch_ratio_mean)
```
High switching ratio --> low number samples 

Correlation between switch ratio and sampling total

```{r}

cor(main_dt$sampling_total, main_dt$sampling_switch_ratio_mean, use = "complete.obs")

```

# Sampling strategies 

The most important question will ask will be : How is sampling switch ratio and proportion of seen_exval works together?

Before going into details for that, let's check seen_exval and seen_exval_chosen and understand their definition clearly. 

seen_exval shows the which option has higher expected value. If both option have same expected value, then it will be NA. Same definition used with "exval" 

!!!! Question: When is the difference between seen_evA and seen_evB significantly small? --> Ignore

## Create seen_winner_chosen and seen_exval_chosen

```{r}

# Let's create a column called "seen_exval_chosen" which will show if the choice is same with the seen_exval. However if
# seen_exval is NA, there won't be effect. so if exval_seen is NA, seen_exval_chosen will be no difference. 

# same logic for seen_winner_chosen

main_dt[, seen_exval_chosen := ifelse(is.na(seen_exval), "no difference", ifelse(choice == seen_exval, TRUE, FALSE))]

main_dt[, seen_winner_chosen := ifelse(is.na(seen_winner), "unindentified", ifelse(choice == seen_winner, TRUE, FALSE))]

```


## Decision variables descriptives

```{r}

# seen_exval_chosen and seen_winner_chosen are used to calculate choice proportions later on. Before comparing the relations between 
# switching ratio and decision metrics, we can briefly check some descriptives 

main_dt[, .N , by = seen_exval_chosen]

main_dt[, .N, by = c( "dom", "seen_exval_chosen")][order(seen_exval_chosen)][order(dom)]

main_dt[, .N , by = seen_winner_chosen]

main_dt[, .N, by = c( "dom", "seen_winner_chosen")][order(seen_winner_chosen)][order(dom)]

main_dt[, .N, by = c("seen_exval_chosen", "seen_winner_chosen")][order(seen_winner_chosen)][order(seen_exval_chosen)]

main_dt[seen_exval == seen_winner, .N]



```


### Switching probabilities vs. decision variables 

```{r}
# Round switching ratio to 2 decimal 
main_dt[, sampling_switch_ratio:= round(sampling_switch_ratio, 1)]

# create a subset of main where seen_exval is not equal to seen_winner
segment_dt <- main_dt[seen_exval != seen_winner, ]

# Calculate proportion of choices based switch ratio - seen_exval_chosen
main_dt[, seen_exval_chosen_proportion := round(sum(seen_exval_chosen == TRUE, na.rm = TRUE) / .N ,1), by = sampling_switch_ratio]
segment_dt[, seen_exval_chosen_proportion := round(sum(seen_exval_chosen == TRUE, na.rm = TRUE) / .N ,1), by = sampling_switch_ratio]

# Calculate proportion of choices based switch ratio - seen_winner_chosen
main_dt[, seen_winner_chosen_proportion := round(sum(seen_winner_chosen == TRUE, na.rm = TRUE) / .N ,1), by = sampling_switch_ratio]
segment_dt[, seen_winner_chosen_proportion := round(sum(seen_winner_chosen == TRUE, na.rm = TRUE) / .N ,1), by = sampling_switch_ratio]

# Create graphs: sampling_switch_ratio vs seen_exval_chosen_proportion

ggplot(main_dt, aes(x = sampling_switch_ratio, y = seen_exval_chosen_proportion)) + geom_line() + geom_point() + geom_smooth()

ggplot(segment_dt, aes(x = sampling_switch_ratio, y = seen_exval_chosen_proportion)) + geom_line() + geom_point() + geom_smooth()


# Create graphs: sampling_switch_ratio vs seen_winner_chosen_proportion

ggplot(main_dt, aes(x = sampling_switch_ratio, y = seen_winner_chosen_proportion)) + geom_line() + geom_point() + geom_smooth()

ggplot(segment_dt, aes(x = sampling_switch_ratio, y = seen_winner_chosen_proportion)) + geom_line() + geom_point() + geom_smooth()

              
```


```{r}
# decimal is 2

# Round switching ratio to 2 decimal 
main_dt[, sampling_switch_ratio:= round(sampling_switch_ratio, 2)]

# create a subset of main where seen_exval is not equal to seen_winner
segment_dt <- main_dt[seen_exval != seen_winner, ]

# Calculate proportion of choices based switch ratio - seen_exval_chosen
main_dt[, seen_exval_chosen_proportion := round(sum(seen_exval_chosen == TRUE, na.rm = TRUE) / .N , 2), by = sampling_switch_ratio]
segment_dt[, seen_exval_chosen_proportion := round(sum(seen_exval_chosen == TRUE, na.rm = TRUE) / .N , 2), by = sampling_switch_ratio]

# Calculate proportion of choices based switch ratio - seen_winner_chosen
main_dt[, seen_winner_chosen_proportion := round(sum(seen_winner_chosen == TRUE, na.rm = TRUE) / .N , 2), by = sampling_switch_ratio]
segment_dt[, seen_winner_chosen_proportion := round(sum(seen_winner_chosen == TRUE, na.rm = TRUE) / .N , 2), by = sampling_switch_ratio]

# Create graphs: sampling_switch_ratio vs seen_exval_chosen_proportion

ggplot(main_dt, aes(x = sampling_switch_ratio, y = seen_exval_chosen_proportion)) + geom_line() + geom_point() + geom_smooth()

ggplot(segment_dt, aes(x = sampling_switch_ratio, y = seen_exval_chosen_proportion)) + geom_line() + geom_point() + geom_smooth()


# Create graphs: sampling_switch_ratio vs seen_winner_chosen_proportion

ggplot(main_dt, aes(x = sampling_switch_ratio, y = seen_winner_chosen_proportion)) + geom_line() + geom_point() + geom_smooth() 

ggplot(segment_dt, aes(x = sampling_switch_ratio, y = seen_winner_chosen_proportion)) + geom_line() + geom_point() + geom_smooth() 

# Create graphs: sampling_switch_ratio vs seen_winner_chosen_proportion

ggplot(main_dt, aes(x = sampling_switch_ratio, y = seen_winner_chosen_proportion)) + geom_line() + geom_point() + geom_smooth() + facet_grid(dom ~ . )

ggplot(segment_dt, aes(x = sampling_switch_ratio, y = seen_winner_chosen_proportion)) + geom_line() + geom_point() + geom_smooth() + facet_grid(dom ~ . )

```

## Logistic regression 

Create training and test data 
```{r}

# Make choice numeric 
main_dt[, choice := ifelse(choice == 'A', 0, 1)]
segment_dt[, choice := ifelse(choice == 'A', 0, 1)]


# Make seen_exval numeric 
main_dt[, seen_exval := ifelse(seen_exval == 'A', 0, 1)]
segment_dt[, seen_exval := ifelse(seen_exval == 'A', 0, 1)]

# Make seen_winner numeric 
main_dt[, seen_winner := ifelse(seen_winner == 'A', 0, 1)]
segment_dt[, seen_winner := ifelse(seen_winner == 'A', 0, 1)]

# Split the data into training and test set for main_dt
# Use 80% of dataset as training set and remaining 30% as testing set
set.seed(123)
sample <- sample(c(TRUE, FALSE), nrow(main_dt), replace=TRUE, prob=c(0.8,0.2))
train.main_dt <- main_dt[sample, ]
test.main_dt <- main_dt[!sample, ]  

# Split the data into training and test set for segment_dt
sample <- sample(c(TRUE, FALSE), nrow(segment_dt), replace=TRUE, prob=c(0.8,0.2))
train.segment_dt <- segment_dt[sample, ]
test.segment_dt <- segment_dt[!sample, ]  

```

Create model for main_dt

```{r}

# Fit the model

log_model1 <- glm( choice ~ sampling_switch_ratio , data = train.main_dt, family = binomial)

# Summarize the model
summary(log_model1)

# Make predictions
probabilities <- log_model1 %>% predict(test.main_dt, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, 1, 0)

# Model accuracy
mean(predicted.classes == test.main_dt$choice, na.rm = TRUE)

```



Create model for segment_dt

```{r}

# Fit the model
log_model1.seg<- glm( choice ~ sampling_switch_ratio , data = train.segment_dt, family = binomial)

# Summarize the model
summary(log_model1.seg)

# Make predictions
probabilities <- log_model1.seg %>% predict(test.segment_dt, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, 1, 0)

# Model accuracy
mean(predicted.classes == test.segment_dt$choice, na.rm = TRUE)

```

Create model for main_dt

```{r}

# Fit the model

log_model2 <- glm( choice ~ sampling_switch_ratio + sampling_total, data = train.main_dt, family = binomial)

# Summarize the model
summary(log_model2)

# Make predictions
probabilities <- log_model2 %>% predict(test.main_dt, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, 1, 0)

# Model accuracy
mean(predicted.classes == test.main_dt$choice, na.rm = TRUE)

```



Create model for segment_dt

```{r}

# Fit the model
log_model2.seg<- glm( choice ~ sampling_switch_ratio + sampling_total, data = train.segment_dt, family = binomial)

# Summarize the model
summary(log_model2.seg)

# Make predictions
probabilities <- log_model2.seg %>% predict(test.segment_dt, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, 1, 0)

# Model accuracy
mean(predicted.classes == test.segment_dt$choice, na.rm = TRUE)

```
```{r}

# Fit the model

log_model3 <- glm( choice ~ sampling_switch_ratio + seen_exval, data = train.main_dt, family = binomial)

# Summarize the model
summary(log_model3)

# Make predictions
probabilities <- log_model3 %>% predict(test.main_dt, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, 1, 0)

# Model accuracy
mean(predicted.classes == test.main_dt$choice, na.rm = TRUE)

```



Create model for segment_dt

```{r}

# Fit the model
log_model3.seg<- glm( choice ~ sampling_switch_ratio + seen_exval, data = train.segment_dt, family = binomial)

# Summarize the model
summary(log_model3.seg)

# Make predictions
probabilities <- log_model3.seg %>% predict(test.segment_dt, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, 1, 0)

# Model accuracy
mean(predicted.classes == test.segment_dt$choice, na.rm = TRUE)

```

Create model for main_dt


```{r}
# Fit the model

log_model4 <- glm( choice ~ sampling_switch_ratio + seen_winner, data = train.main_dt, family = binomial)

# Summarize the model
summary(log_model4)

# Make predictions
probabilities <- log_model4 %>% predict(test.main_dt, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, 1, 0)

# Model accuracy
mean(predicted.classes == test.main_dt$choice, na.rm = TRUE)

```



Create model for segment_dt

```{r}

# Fit the model
log_model4.seg<- glm( choice ~ sampling_switch_ratio + seen_winner ,data = train.segment_dt, family = binomial)

# Summarize the model
summary(log_model4.seg)

# Make predictions
probabilities <- log_model4.seg %>% predict(test.segment_dt, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, 1, 0)

# Model accuracy
mean(predicted.classes == test.segment_dt$choice, na.rm = TRUE)

```


```{r}
# Fit the model

log_model5 <- glm( choice ~ sampling_switch_ratio + seen_winner + seen_exval, data = train.main_dt, family = binomial)

# Summarize the model
summary(log_model5)

# Make predictions
probabilities <- log_model5 %>% predict(test.main_dt, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, 1, 0)

# Model accuracy
mean(predicted.classes == test.main_dt$choice, na.rm = TRUE)

```



Create model for segment_dt

```{r}

# Fit the model
log_model5.seg<- glm( choice ~ sampling_switch_ratio + seen_winner + seen_exval ,data = train.segment_dt, family = binomial)

# Summarize the model
summary(log_model5.seg)

# Make predictions
probabilities <- log_model5.seg %>% predict(test.segment_dt, type = "response")
predicted.classes <- ifelse(probabilities > 0.5, 1, 0)

# Model accuracy
mean(predicted.classes == test.segment_dt$choice, na.rm = TRUE)

```



# Sampling clusters  


We decided to look further into sampling variables and make some transformation 

Let's look at all sampling related metrics and their histogram 


```{r}

sampling_temp <- main_dt[, c("sampling_total", "sampling_total_switch", "sampling_round_total",  "sampling_switch_ratio")]

ggplot(sampling_temp, aes(x = sampling_total)) + geom_histogram(binwidth = 2, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_total_switch " ,
       x = "Switching Total",
       y = "Frequency")

# --> right skewed

ggplot(sampling_temp, aes(x = sampling_total_switch)) + geom_histogram(binwidth = 2, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_total_switch " ,
       x = "sampling_total_switch",
       y = "Frequency")

# --> right skewed

ggplot(sampling_temp, aes(x = sampling_round_total)) + geom_histogram(binwidth = 2, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_round_total " ,
       x = "sampling_round_total",
       y = "Frequency")

# --> right skewed


ggplot(sampling_temp, aes(x = sampling_switch_ratio)) + geom_histogram(binwidth = 0.1, fill="black", col="grey") + 
  labs(title = "Histogram of sampling_switch_ratio " ,
       x = "sampling_switch_ratio",
       y = "Frequency")
# --> bimodal 


```

We can use normalization (scale),  logartihmic transformation or Square root transformation for the right skewed ones 
Also use nromal distribution check after the transformation


```{r}

# Apply normalization
sampling_temp[, norm_sampling_total := scale(sampling_total)]
sampling_temp[, norm_sampling_total_switch := scale(sampling_total_switch)]

# histograms
ggplot(sampling_temp, aes(norm_sampling_total)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_total")
ggplot(sampling_temp, aes(norm_sampling_total_switch)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_total_switch")


# normal distribution tests
ks.test(sampling_temp$norm_sampling_total, "pnorm")
ks.test(sampling_temp$norm_sampling_total_switch, "pnorm")


# Apply logarithmic transformation
sampling_temp[, log_sampling_total := log(sampling_total)]
sampling_temp[, log_sampling_total_switch := log(sampling_total_switch)]

#histograms 
ggplot(sampling_temp, aes(log_sampling_total)) + geom_histogram(binwidth = 0.5) + labs(x = "log_sampling_total")
ggplot(sampling_temp, aes(log_sampling_total_switch)) + geom_histogram(binwidth = 0.5) + labs(x = "log_sampling_total_switch")


# normal distribution tests
ks.test(sampling_temp$log_sampling_total, "pnorm")
ks.test(sampling_temp$log_sampling_total_switch, "pnorm")

# Apply square root transformation
sampling_temp[, sr_sampling_total := sqrt(sampling_total)]
sampling_temp[, sr_sampling_total_switch := sqrt(sampling_total_switch)]

#histograms 
ggplot(sampling_temp, aes(sr_sampling_total)) + geom_histogram(binwidth = 1) + labs(x = "sr_sampling_total")
ggplot(sampling_temp, aes(sr_sampling_total_switch)) + geom_histogram(binwidth = 1) + labs(x = "sr_sampling_total_switch")

# normal distribution tests
ks.test(sampling_temp$sr_sampling_total, "pnorm")
ks.test(sampling_temp$sr_sampling_total_switch, "pnorm")

```


```{r}
# I will use similar simialr approaches for the ratios 
# but they are bimodel!

# I will try normalize, log, squared root transformation


# Apply normalization
sampling_temp[, norm_sampling_switch_ratio := scale(sampling_switch_ratio)]

# histograms
#ggplot(sampling_temp, aes(norm_sampling_ratio)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_ratio")
ggplot(sampling_temp, aes(norm_sampling_switch_ratio)) + geom_histogram(binwidth = 0.5) + labs(x = "norm_sampling_switch_ratio")

# normal distribution tests
ks.test(sampling_temp$norm_sampling_switch_ratio, "pnorm")

# Apply logarithmic transformation
sampling_temp[, log_sampling_switch_ratio := log(sampling_switch_ratio)]

#histograms 
ggplot(sampling_temp, aes(log_sampling_switch_ratio)) + geom_histogram(binwidth = 0.5) + labs(x = "log_sampling_switch_ratio")



# normal distribution tests
ks.test(sampling_temp$log_sampling_switch_ratio, "pnorm")


# Apply square root transformation
sampling_temp[, sr_sampling_switch_ratio := sqrt(sampling_switch_ratio)]

#histograms 
#ggplot(sampling_temp, aes(sr_sampling_ratio)) + geom_histogram(binwidth = 0.1) + labs(x = "sr_sampling_ratio")
ggplot(sampling_temp, aes(sr_sampling_switch_ratio)) + geom_histogram(binwidth = 0.1) + labs(x = "sr_sampling_switch_ratio")


# normal distribution tests
ks.test(sampling_temp$sr_sampling_switch_ratio, "pnorm")


```

  - So I think the important metrics are switching ratio and sampling total for clustering
  - if we think low, medium and high for both of them, we should be expecting 9 clusters 
  - When we were calculating switching ratio, we decided to exclude first sampling but it caused 
  48 of NA data. Just to prevent it, I created sampling_switch_ratio_2 
  - I will create a sampling_real variable which is the sampling_total - sampling_total_switching to decrease the effect of sampling total 
  - I will check histogram of sampling ratio, sampling total, sampling_real
  - I will create a k-means cluster by using these 2 metrics with 9 clusters
  - If it doesn't pass the visual evaluation, I will try to create 9 clusters myself


```{r}

main_dt[, sampling_real := (sampling_total - sampling_total_switch)]

# create a graph sampling total vs sampling switch ratio 
ggplot(main_dt, aes(x = sampling_switch_ratio , y = sampling_total)) + geom_point()
ggplot(main_dt, aes(x = sampling_total_switch , y = sampling_real)) + geom_point()

```

```{r}
# Create histograms of sampling_total, sampling_real, sampling_switch_ratio
hist(main_dt$sampling_real)
hist(main_dt$sampling_total)
hist(main_dt$sampling_total_switch)
hist(main_dt$sampling_switch_ratio)

# let's use log transformation for the first two and scale for the last one. 


```



```{r}
# Sampling model 

model_dt<- as.data.table(main_dt[sampling_total_switch != 0, c("identifier","sampling_total", "sampling_total_switch", "sampling_real", "sampling_switch_ratio")])


# Apply logarithmic transformation
model_dt[, log_sampling_total_switch := log(sampling_total_switch)]
model_dt[, log_sampling_real := log(sampling_real)]


model_dt[, scale_sampling_total_switch := scale(sampling_total_switch)]
model_dt[, scale_sampling_real := scale(sampling_real)]

# Perform k-means clustering 
k <- 9
model_result <- kmeans(model_dt[, c("log_sampling_real", "log_sampling_total_switch")], centers = k, nstart = 10)

# Add the cluster assignments as a new column in the data table
model_dt$cluster <- as.factor(model_result$cluster)

# plots
ggplot(model_dt, aes(sampling_real, sampling_total_switch, color = cluster)) + geom_point()

ggplot(model_dt, aes(log_sampling_real, log_sampling_total_switch, color = cluster)) + geom_point()

ggplot(model_dt, aes(sampling_switch_ratio, sampling_total, color = cluster)) + geom_point()


```

```{r}
# scree plot 
# Initialize total within sum of squares error: wss
wss <- 0

# For 1 to 15 cluster centers
for (i in 1:15) {
  km.out <- kmeans(model_dt[, c("log_sampling_real", "log_sampling_total_switch")], centers = i)
  # Save total within sum of squares to wss variable
  wss[i] <- km.out$tot.withinss

}

# Plot total within sum of squares vs. number of clusters
plot(1:15, wss, type = "b", 
     xlab = "Number of Clusters", 
     ylab = "Within groups sum of squares")

```

## Sampling clusters vs. choice proportions

```{r}
# add cluster to main_dt and segment_dt
main_dt <- main_dt %>% left_join (model_dt, by = 'identifier')
segment_dt <- segment_dt %>% left_join(model_dt, by = 'identifier')

# Create graphs: sampling_switch_ratio vs seen_exval_chosen_proportion

ggplot(main_dt, aes(x = cluster, y = seen_exval_chosen_proportion)) + geom_line() + geom_point()

ggplot(segment_dt, aes(x = cluster, y = seen_exval_chosen_proportion)) + geom_line() + geom_point()


# Create graphs: sampling_switch_ratio vs seen_winner_chosen_proportion

ggplot(main_dt, aes(x = cluster , y = seen_winner_chosen_proportion)) + geom_line() + geom_point() + geom_smooth() + facet_grid(dom ~ . )

ggplot(segment_dt, aes(x = cluster, y = seen_winner_chosen_proportion)) + geom_line() + geom_point() + geom_smooth() + facet_grid(dom ~ . )


```




