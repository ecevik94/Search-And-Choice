---
title: "Data cleaning and creating new variables"
author: "Emine Cevik"
date: "`r Sys.Date()`"
output: html_document
---
```{r}
here::i_am("Code/DataCleaning_exp.Rmd")
```


```{r setup, include = TRUE, echo = FALSE}
knitr::opts_chunk$set(message = FALSE)

```


```{r, warning = FALSE, echo = TRUE}
library(tidyverse)
library(data.table)
library(fpCompare)
library(openxlsx)
library(here)
```


# Basics
Read exp.txt file and create a data table 
```{r, echo = TRUE}
exp_df <- read.table(here("Data", "exp.txt"))
exp_dt <- as.data.table(exp_df)

# exp_dt is the raw data from exp.txt file 

```

Check the raw data 
```{r, warning = FALSE, echo = TRUE}

str(exp_dt)

# check na counts for all columns 

na_count <-sapply(exp_dt, function(x) sum(length(which(is.na(x)))))
na_count <- data.frame(na_count)
na_count

# risky, exval, order and orderbin have na entries 

# risky is NA, cov0 = cov1 --> it is fine to keep NA (cov : coefficient of 
# variation of option)
# exval is NA, ev0 = ev1 --> it is fine to keep NA
# order is NA --> position of the problem within the experiment is randomized 
# order bin --> if the problem in the first or second half of the experiment or 
# unknown

# It is okay to proceed with these NAs 

```

Time to filter the raw data 

As a first step, choose the entries with cert = TRUE and type = free

Secondly, eliminate ther columns that we are not going to use 
  - outA3, outA4, outA5, outB3, outB4, outB5
  - probA3, probA4, probA5, probB3, probB4, probB5
  

```{r, warning = FALSE, echo = TRUE}

filtered_exp <- exp_dt %>% filter(cert == TRUE, type =='free' )

# short checks

# 1
# nout should be either 2 or 3

table(filtered_exp$nout)

# 2
# ev0 = outA1*probA1 + outA2*probA2

filtered_exp[, ev0_check := (outA1*probA1) + (outA2*probA2), ]
filtered_exp[ev0_check %!=% ev0,]

# 3
# ev1 = outB1*probB1 + outB2*probB2
filtered_exp[, ev1_check :=  (outB1*probB1) + (outB2*probB2), ]
filtered_exp[ev1_check %!=% ev1,]

# delete ev0_check and ev1_check 
filtered_exp[, c("ev0_check","ev1_check"):= NULL]


# 4 : remove the columns that we are not going to use 
filtered_exp[, c("outA3", "outA4", "outA5", "outB3", "outB4", "outB5", "probA3", "probA4", "probA5", "probB3", "probB4", "probB5") := NULL]

```

# Data cleaning

## Basics

  - We made decisions below to have easier data set 
  - When "choice" is equal to 0 --> A, 1 --> B
  - When "option" is equal to 0 --> A, 1 --> B
  - When "exval" is equal to 0 --> A, 1 --> B (also NA)
  - When "und" is equal to 0 --> A, 1 --> B
  - When "cpt" is equal to 0 --> A, 1 --> B
  - When "risky" is equal to 0 --> A, 1 --> B (also NA)
  - ev0 --> evA
  - ev1 --> evB

```{r, warning = FALSE, echo = TRUE}

cleaned_exp <- filtered_exp %>% as.data.table()

cleaned_exp <- cleaned_exp %>% mutate(choice = ifelse( choice == 0, 'A', 'B'))
cleaned_exp <- cleaned_exp %>% mutate(option = ifelse( option == 0, 'A', 'B'))
cleaned_exp <- cleaned_exp %>% mutate(und = ifelse( und == 0, 'A', 'B'))
cleaned_exp <- cleaned_exp %>% mutate(cpt = ifelse( cpt == 0, 'A', 'B'))
cleaned_exp <- cleaned_exp %>% mutate(exval = ifelse(exval == 0, "A", ifelse(exval == 1, "B", exval)))
cleaned_exp <- cleaned_exp %>% mutate(risky = ifelse(risky == 0, "A", ifelse(risky == 1, "B", risky)))


# since values can be either A or B, created factor 
cleaned_exp$choice <- as.factor(cleaned_exp$choice)
cleaned_exp$option <- as.factor(cleaned_exp$option)
cleaned_exp$und <- as.factor(cleaned_exp$und)
cleaned_exp$cpt <- as.factor(cleaned_exp$cpt)
cleaned_exp$exval <- as.factor(cleaned_exp$exval)
cleaned_exp$risky <- as.factor(cleaned_exp$risky)

# rename ev0 and ev1 
cleaned_exp <- cleaned_exp %>% rename ("evA" = "ev0", 
                                       "evB" = "ev1")

```

Another decision we made was to use ID+Problem+Subject as an identifier for 
a participant and problem. 

Also create a participant column by using id and subject

  - We assume that all subjects in different studies are independent from each 
other
  - Created a column called identifier that basically combination of ID, Problem, and 
Subject 

```{r, echo = TRUE}
#identifier
cleaned_exp <- cleaned_exp %>% unite("identifier", c('id', 'subject', 'problem'), sep = "-", remove = FALSE)


#participant
cleaned_exp <- cleaned_exp %>% unite("participant", c('id', 'subject'), sep = "-", remove = FALSE)

```

## Create columns related to run & trials  

  - seen_outcome (A1, A2, B1, B2)
  - seen_option (same as option)
  - seen_nout (number of distinct seen_outcome)
  - seen_all (boolean)
  - seen_A (how many time that the participant saw option A in the run)
  - seen_B (how many time that the participant saw option B in the run)
  - seen_A1 (how many time that the participant saw outcome A1 in the run)
  - seen_A2 (how many time that the participant saw outcome A2 in the run)
  - seen_B1 (how many time that the participant saw outcome B1 in the run)
  - seen_B2 (how many time that the participant saw outcome B2 in the run)
  - seen_probA1 
  - seen_probA2
  - seen_probB1
  - seen_probB2
  - seen_evA
  - seen_evB
  - seen_sameDistA
  - seen_sameDistB
  - seen_covA
  - seen_covB

Later, I also decided to add

  - seen_ev_diff
  - seen_exval 
  

```{r, echo = TRUE}

# Let's start with column seen_all (boolean)
# note: it is important to use option condition because outcomes could be same in option A and B
cleaned_exp <- cleaned_exp %>% mutate(seen_outcome = case_when 
                                      ( option == 'A' & outcome == outA1 ~ 'A1',
                                        option == 'A' & outcome == outA2 ~ 'A2',
                                        option == 'B' & outcome == outB1 ~ 'B1',
                                        option == 'B' & outcome == outB2 ~ 'B2'))


# seen_option : even though it is exactly same with option column, I want to have it 
# for sanitary check later on
cleaned_exp <- cleaned_exp %>% mutate(seen_option = option)


# seen_nout (number of distinct seen_outcome)
cleaned_exp <- cleaned_exp %>%group_by(identifier) %>% 
  mutate(seen_nout = n_distinct(seen_outcome))


# seen_all (boolean)
# since mutate function is computationally heavy, I used data table function 
# I used mutate, so it is safe to check if cleaned_exop is still data table

cleaned_exp <- as.data.table(cleaned_exp)
cleaned_exp[, seen_all := ifelse(nout == seen_nout, TRUE, ifelse(nout > seen_nout, FALSE, NA))]


# seen_A
# count option A in a the run 
cleaned_exp <- cleaned_exp %>%  group_by(identifier) %>% 
  mutate(seen_A = sum(option == "A")) %>% 
  ungroup()


# seen_B
# count option A in a the run 
cleaned_exp <- cleaned_exp %>%  group_by(identifier) %>% 
  mutate(seen_B = sum(option == "B")) %>% 
  ungroup()



# seen_A1 (how many time that the participant saw outcome A1 in the run)
cleaned_exp <- cleaned_exp %>%  group_by(identifier) %>% 
  mutate(seen_A1 = sum(seen_outcome == "A1")) %>% 
  ungroup()


# seen_A2 (how many time that the participant saw outcome A2 in the run)
cleaned_exp <- cleaned_exp %>%  group_by(identifier) %>% 
  mutate(seen_A2 = sum(seen_outcome == "A2")) %>% 
  ungroup()


# seen_B1 (how many time that the participant saw outcome A1 in the run)
cleaned_exp <- cleaned_exp %>%  group_by(identifier) %>% 
  mutate(seen_B1 = sum(seen_outcome == "B1")) %>% 
  ungroup()


# seen_B2 (how many time that the participant saw outcome A2 in the run)
cleaned_exp <- cleaned_exp %>%  group_by(identifier) %>% 
  mutate(seen_B2 = sum(seen_outcome == "B2")) %>% 
  ungroup()


# seen_probA1 = seen_A1/seen_A
cleaned_exp <- as.data.table(cleaned_exp)
cleaned_exp[, seen_probA1 := round(seen_A1 / seen_A, 3)]


# seen_probA2 = seen_A2/seen_A
cleaned_exp[, seen_probA2 := round(seen_A2 / seen_A, 3)]


# seen_probB1 = seen_B1/seen_B
cleaned_exp[, seen_probB1 := round(seen_B1 / seen_B, 3)]


# seen_probB2 = seen_B2/seen_B
cleaned_exp[, seen_probB2 := round(seen_B2 / seen_B, 3)]


# seen_evA = outA1*seen_probA1 + outA2*seen_probA2
cleaned_exp[, seen_evA := round(outA1*seen_probA1 + outA2*seen_probA2, 3)]


# seen_evB = outB1*seen_probB1 + outB2*seen_probB2
cleaned_exp[, seen_evB := round(outB1*seen_probB1 + outB2*seen_probB2, 3)]


# seen_sameDistA
cleaned_exp[, seen_sameDistA := ifelse(evA %==% seen_evA, TRUE, FALSE)]


# seen_sameDistB
cleaned_exp[, seen_sameDistB := ifelse(evB %==% seen_evB, TRUE, FALSE)]


# seen_ev_diff: difference between seen expected values
cleaned_exp[, seen_ev_diff := seen_evA - seen_evB]


# seen_exval: same logic with exval but for seen 
cleaned_exp[, seen_exval := ifelse(seen_evA > seen_evB, "A",
                                   ifelse(seen_evA < seen_evB, "B", NA_character_))]

# Convert "outcome" to numeric
cleaned_exp[, outcome := as.numeric(outcome)]

# In order to calculate coefficient of variation, we need to calculate mean and std 

# seen_meanA 
cleaned_exp <- cleaned_exp %>%
  group_by(identifier) %>%
  mutate(seen_meanA = mean(outcome[option == "A"], na.rm = TRUE)) %>%
  ungroup()

# seen_meanB
cleaned_exp <- cleaned_exp %>%
  group_by(identifier) %>%
  mutate(seen_meanB = mean(outcome[option == "B"], na.rm = TRUE)) %>%
  ungroup()


# seen_stdA
cleaned_exp <- cleaned_exp %>%
  group_by(identifier) %>%
  mutate(seen_stdA = sd(outcome[option == "A"], na.rm = TRUE)) %>%
  ungroup()

# seen_stdB
cleaned_exp <- cleaned_exp %>%
  group_by(identifier) %>%
  mutate(seen_stdB = sd(outcome[option == "B"], na.rm = TRUE)) %>%
  ungroup()

# seen_covA
cleaned_exp <- as.data.table(cleaned_exp)

cleaned_exp[, seen_covA := (seen_stdA / seen_meanA) , by = identifier]

# seen_covB
cleaned_exp[, seen_covB := (seen_stdB / seen_meanB) , by = identifier]

# seen_risky
cleaned_exp[, seen_risky := ifelse(!is.na(seen_covA) & !is.na(seen_covB), ifelse(seen_covA > seen_covB, "A",
                                                                                 ifelse(seen_covB > seen_covA, "B", 
                                                                                        NA_character_)),
                                                                                      "unidentified") ]

```
  
  - seen_winner:option has higher outcome and option that is a winner for piecewise comparison
  
  
```{r}
cleaned_exp <- cleaned_exp %>% mutate(seen_outcomeA_higher_prob := case_when 
                                      (seen_probA1 > seen_probA2 ~ outA1,
                                       seen_probA1 < seen_probA2 ~ outA2))

cleaned_exp <- cleaned_exp %>% mutate(seen_optionA_higher_prob := case_when 
                                      ( seen_probA1 > seen_probA2 ~ 'A1',
                                        seen_probA1 < seen_probA2 ~ 'A2'))

cleaned_exp <- cleaned_exp %>% mutate(seen_outcomeB_higher_prob := case_when 
                                      ( seen_probB1 > seen_probB2 ~ outB1,
                                        seen_probB1 < seen_probB2 ~ outB2))

cleaned_exp <- cleaned_exp %>% mutate(seen_optionB_higher_prob := case_when 
                                      ( seen_probB1 > seen_probB2 ~ 'B1',
                                        seen_probB1 < seen_probB2 ~ 'B2'))

cleaned_exp[, seen_winner := ifelse( seen_outcomeA_higher_prob > seen_outcomeB_higher_prob, "A", "B") ]

# seen_winner will return in such cases:
# - seen_probA1 and seen_probA2 are 0.5 or seen_probB1 and seen_probB2 are 0.5
# - oen of the option has been sampled (eg: never sampled from option B)

```
  


## Create columns related to sampling behavior

  - sampling_total
  - sampling_switch_total
  - sampling_switch
  - sampling_switch_ratio


```{r, echo = TRUE}

# sampling_total 
# we can use count trials by identifier or max trial number by identifier 
# but finding max is operationally less costly than counting 
cleaned_exp[, sampling_total := max(trial), by = identifier]


# sampling switch 
# I used lag to get the previous option
cleaned_exp[, sampling_switch := ifelse(trial == 1, "first",
                                         ifelse(option != lag(option), "yes", "no")), by = identifier]


# sampling_total_switch (number of yes in the run by identifier)
cleaned_exp[, sampling_total_switch := sum(sampling_switch == "yes"), by = identifier]


# sampling_switch_ratio (sampling_total_switch/(sampling_total-1))
cleaned_exp[, sampling_switch_ratio := round(sampling_total_switch/(sampling_total-1), 3), by = identifier]


```


  - sampling_round: uninterrepted sequence of options 

```{r, echo = TRUE}


# Initialize "number of yes" to 0 for each identifier
temp[, number_of_yes := 0, by = identifier]

# Update "number of yes" based on "sampling_switch" column
temp[, number_of_yes := cumsum(sampling_switch == "yes"), by = identifier]


# Initialize round column with NAs
temp$round <- NA

# Iterate through each row
current_round <- 1

for (i in 1:nrow(temp)) {

  if (temp$sampling_switch[i] == "first") {
    temp$round[i] <- 1
    current_round <- 1
  }

  if (i > 1 && temp$identifier[i] == temp$identifier[i - 1]) {
    if (temp$number_of_yes[i] == temp$number_of_yes[i - 1]) {
      temp$round[i] <- current_round
    } else {
      if (temp$number_of_yes[i] %% 2 != 0) {
        temp$round[i] <- current_round
      } else {
        current_round <- current_round + 1
        temp$round[i] <- current_round
      }
    }
  }
}

cleaned_exp[, sampling_round := temp$round]

cleaned_exp[, round := temp$round]
```

# Precise definition for round winner 
round means uninterrepted sequence of options. Based on thi definition, some rounds might be uncompleted. 

# Seen_winner vs piecewise winner 
```{r}

# 1- create column called round completed
# we will use this column to create a different cases --> robust analysis 
cleaned_exp[, round_completed := ifelse(uniqueN(option) == 2, TRUE, FALSE), by = c("identifier", "round")]


```

# 2 - round winner: higher mean valued option over a round 

We will use seen_exval logic 
  1- round_seen_A & round_seen_B
  2- round_seen_A1 & round_seen_B1
  3- round_seen_A2 & round_seen_B2
  4- round_seen_probA1 & round_seen_probB1
  5- round_seen_probA2 & round_seen_probB2
  6- round_seen_evA & round_seen_evB
  7- round_winner 
  8- piecewise_winner 
  
```{r}

# round_seen_A
# count option A in a the run 
cleaned_exp <- cleaned_exp %>%  group_by(identifier, round) %>% 
  mutate(round_seen_A = sum(option == "A")) %>% 
  ungroup()


# round_seen_B
# count option A in a the run 
cleaned_exp <- cleaned_exp %>%  group_by(identifier, round) %>% 
  mutate(round_seen_B = sum(option == "B")) %>% 
  ungroup()



# round_seen_A1 (how many time that the participant saw outcome A1 in the run)
cleaned_exp <- cleaned_exp %>%  group_by(identifier, round) %>% 
  mutate(round_seen_A1 = sum(seen_outcome == "A1")) %>% 
  ungroup()


# round_seen_A2 (how many time that the participant saw outcome A2 in the run)
cleaned_exp <- cleaned_exp %>%  group_by(identifier, round) %>% 
  mutate(round_seen_A2 = sum(seen_outcome == "A2")) %>% 
  ungroup()


# round_seen_B1 (how many time that the participant saw outcome A1 in the run)
cleaned_exp <- cleaned_exp %>%  group_by(identifier) %>% 
  mutate(round_seen_B1 = sum(seen_outcome == "B1")) %>% 
  ungroup()


# round_seen_B2 (how many time that the participant saw outcome A2 in the run)
cleaned_exp <- cleaned_exp %>%  group_by(identifier, round) %>% 
  mutate(round_seen_B2 = sum(seen_outcome == "B2")) %>% 
  ungroup()


# round_seen_probA1 = round_seen_A1/round_seen_A
cleaned_exp <- as.data.table(cleaned_exp)
cleaned_exp[, round_seen_probA1 := round(round_seen_A1 / round_seen_A, 3)]


# round_seen_probA2 = round_seen_A2/round_seen_A
cleaned_exp[, round_seen_probA2 := round(round_seen_A2 / round_seen_A, 3)]


# round_seen_probB1 = round_seen_B1/round_seen_B
cleaned_exp[, round_seen_probB1 := round(round_seen_B1 / round_seen_B, 3)]


# round_seen_probB2 = round_seen_B2/round_seen_B
cleaned_exp[, round_seen_probB2 := round(round_seen_B2 / round_seen_B, 3)]


# round_seen_evA = outA1*round_seen_probA1 + outA2*round_seen_probA2
cleaned_exp[, round_seen_evA := round(outA1*round_seen_probA1 + outA2*round_seen_probA2, 3)]


# round_seen_evB = outB1*round_seen_probB1 + outB2*round_seen_probB2
cleaned_exp[, round_seen_evB := round(outB1*round_seen_probB1 + outB2*round_seen_probB2, 3)]


```


# Round winner 
When round is *completed*
  - round_seen_evA > round_seen_evB --> round_winner : A
  - round_seen_evB > round_seen_evA --> round_winner : B
  - round_seen_evA = round_seen_evA --> round_winner : no winner 

When round is *uncomplete* 
  - round_winner : undefined 
  
  
```{r}

cleaned_exp[, round_winner := ifelse( round_completed == FALSE, "undefined", 
                                      ifelse(round_seen_evA > round_seen_evB, "A", 
                                             ifelse(round_seen_evA < round_seen_evB, "B", 
                                                    "no winner")))]
```



# Roundwise winner 

Definition
Based on only "completed" rounds, compare the number of times A and B 
were winners 
  - round_winner_A : how many times A was the round winner 
  - round_winner_B : how many times B was the round winner 
  
roundwise_winner 
  - round_winner_A > round_winner_B --> roundwise_winner : A 
  - round_winner_B > round_winner_A --> roundwise_winner : B   
  - round_winner_A = round_winner_B --> roundwise_winner : no winner  


```{r}

# round_winner_A 
# i will use same logic that I used for round calculation 


# Initialize round_winner_A and round_winner_B for each identifier
temp2$round_winner_A <- 0
temp2$round_winner_B <- 0


for(i in 1:nrow (temp2)) {
  if (i == 1)
  {
    total_A <- 0
    total_B <- 0
    
    if(temp2$round_winner[i] == "A") {
      total_A <- total_A + 1 
      temp2$round_winner_A[i] <- total_A
      temp2$round_winner_B[i] <- total_B
      
    } else if (temp2$round_winner[i] == "B") {
      total_B <- total_B + 1 
      temp2$round_winner_A[i] <- total_A
      temp2$round_winner_B[i] <- total_B
      
    } else {
      temp2$round_winner_A[i] <- total_A
      temp2$round_winner_B[i] <- total_B
    }
  } else {
    
    # check if we are still looking at the same identifier 
    if(temp2$identifier[i] == temp2$identifier[i-1]) {
      
      # check if we are still looking at the same round 
      if(temp2$round[i] == temp2$round[i-1]) {
        temp2$round_winner_A[i] <- temp2$round_winner_A[i-1]
        temp2$round_winner_B[i] <- temp2$round_winner_B[i-1]     
      } else {
      if(temp2$round_winner[i] == "A") {
        total_A <- total_A + 1 
      } else if (temp2$round_winner[i] == "B") {
        total_B <- total_B + 1 
      } else {
        total_A <- total_A + 0
        total_B <- total_B + 0
      }
        temp2$round_winner_A[i] <- total_A
        temp2$round_winner_B[i] <- total_B
    }
    } else {
      total_A <- 0
      total_B <- 0 
      
      if (temp2$round_winner[i] == "A") {
        total_A <- total_A + 1 
      } else if (temp2$round_winner[i] == "B") {
        total_B <- total_B + 1 
      } else {
        total_A <- total_A + 0
        total_B <- total_B + 0
      }
      
      temp2$round_winner_A[i] <- total_A
      temp2$round_winner_B[i] <- total_B
  }
  }
}
  


```

# Roundwise winner 

```{r}

temp2 <- as.data.table(temp2)

temp2[, roundwise_winner := ifelse(max(round_winner_A) == max(round_winner_B), "no winner",
                                                    ifelse(max(round_winner_A) > max(round_winner_B), "A", "B")),
                     by = identifier]

```






```{r, echo = TRUE}

# create a subset

# Decide the columns to select
columns <- c( "identifier", "participant", 
              "dom", "und", "within", "des", "incentives",
              "choice", "cpt", 
              "risky", "seen_risky",
              "exval", "seen_exval",  
              "seen_ev_diff", "seen_all", "seen_A", "seen_B",
              "outA1", "probA1", "seen_probA1", "outA2", "probA2", "seen_probA2",
              "outB1", "probB1", "seen_probB1", "outB2", "probB2", "seen_probB2",
              "evA", "seen_evA", "seen_sameDistA", "evB", "seen_evB", "seen_sameDistB",
              "seen_winner", 
              "seen_outcomeA_higher_prob", "seen_optionA_higher_prob" , "seen_outcomeB_higher_prob","seen_optionB_higher_prob",
              "sampling_total", "sampling_total_switch", "sampling_switch_ratio"
           )

# Create a subset of cleaned_exp by identifier with selected columns
subset_dt <- cleaned_exp[trial == 1 , ..columns ]


# write main data table to excel 
# write.xlsx(subset_dt, file = here("Data", "subset_dt.xlsx"), rowNames = FALSE)
write.csv(subset_dt, file = here("Data", "subset_dt.csv"), row.names = FALSE)


```

It was the process of data cleaning. Now we will use subset_dt as a main data
source for analysis



